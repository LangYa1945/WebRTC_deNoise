#include <string.h>
#include <math.h>
#include <stdlib.h>
#include "include\ns_process.h"
#ifndef SPL_SAT
#define SPL_SAT(a,b,c)	((b)>(a)?(a):(b)<(c)?(c):(b))
#endif

//hanning &flat window

static const float kHanning64w128[128] = {
	0.00000000000000f, 0.02454122852291f, 0.04906767432742f, 0.07356456359967f,
	0.09801714032956f, 0.12241067519922f, 0.14673047445536f, 0.17096188876030f,
	0.19509032201613f, 0.21910124015687f, 0.24298017990326f, 0.26671275747490f,
	0.29028467725446f, 0.31368174039889f, 0.33688985339222f, 0.35989503653499f,
	0.38268343236509f, 0.40524131400499f, 0.42755509343028f, 0.44961132965461f,
	0.47139673682600f, 0.49289819222978f, 0.51410274419322f, 0.53499761988710f,
	0.55557023301960f, 0.57580819141785f, 0.59569930449243f, 0.61523159058063f,
	0.63439328416365f, 0.65317284295378f, 0.67155895484702f, 0.68954054473707f,
	0.70710678118655f, 0.72424708295147f, 0.74095112535496f, 0.75720884650648f,
	0.77301045336274f, 0.78834642762661f, 0.80320753148064f, 0.81758481315158f,
	0.83146961230255f, 0.84485356524971f, 0.85772861000027f, 0.87008699110871f,
	0.88192126434835f, 0.89322430119552f, 0.90398929312344f, 0.91420975570353f,
	0.92387953251129f, 0.93299279883474f, 0.94154406518302f, 0.94952818059304f,
	0.95694033573221f, 0.96377606579544f, 0.97003125319454f, 0.97570213003853f,
	0.98078528040323f, 0.98527764238894f, 0.98917650996478f, 0.99247953459871f,
	0.99518472667220f, 0.99729045667869f, 0.99879545620517f, 0.99969881869620f,
	1.00000000000000f, 0.99969881869620f, 0.99879545620517f, 0.99729045667869f,
	0.99518472667220f, 0.99247953459871f, 0.98917650996478f, 0.98527764238894f,
	0.98078528040323f, 0.97570213003853f, 0.97003125319454f, 0.96377606579544f,
	0.95694033573221f, 0.94952818059304f, 0.94154406518302f, 0.93299279883474f,
	0.92387953251129f, 0.91420975570353f, 0.90398929312344f, 0.89322430119552f,
	0.88192126434835f, 0.87008699110871f, 0.85772861000027f, 0.84485356524971f,
	0.83146961230255f, 0.81758481315158f, 0.80320753148064f, 0.78834642762661f,
	0.77301045336274f, 0.75720884650648f, 0.74095112535496f, 0.72424708295147f,
	0.70710678118655f, 0.68954054473707f, 0.67155895484702f, 0.65317284295378f,
	0.63439328416365f, 0.61523159058063f, 0.59569930449243f, 0.57580819141785f,
	0.55557023301960f, 0.53499761988710f, 0.51410274419322f, 0.49289819222978f,
	0.47139673682600f, 0.44961132965461f, 0.42755509343028f, 0.40524131400499f,
	0.38268343236509f, 0.35989503653499f, 0.33688985339222f, 0.31368174039889f,
	0.29028467725446f, 0.26671275747490f, 0.24298017990326f, 0.21910124015687f,
	0.19509032201613f, 0.17096188876030f, 0.14673047445536f, 0.12241067519922f,
	0.09801714032956f, 0.07356456359967f, 0.04906767432742f, 0.02454122852291f };

// hybrib Hanning & flat window
static const float kBlocks80w128[128] = {
	(float)0.00000000, (float)0.03271908, (float)0.06540313, (float)0.09801714,
	(float)0.13052619, (float)0.16289547, (float)0.19509032, (float)0.22707626,
	(float)0.25881905, (float)0.29028468, (float)0.32143947, (float)0.35225005,
	(float)0.38268343, (float)0.41270703, (float)0.44228869, (float)0.47139674,
	(float)0.50000000, (float)0.52806785, (float)0.55557023, (float)0.58247770,
	(float)0.60876143, (float)0.63439328, (float)0.65934582, (float)0.68359230,
	(float)0.70710678, (float)0.72986407, (float)0.75183981, (float)0.77301045,
	(float)0.79335334, (float)0.81284668, (float)0.83146961, (float)0.84920218,
	(float)0.86602540, (float)0.88192126, (float)0.89687274, (float)0.91086382,
	(float)0.92387953, (float)0.93590593, (float)0.94693013, (float)0.95694034,
	(float)0.96592583, (float)0.97387698, (float)0.98078528, (float)0.98664333,
	(float)0.99144486, (float)0.99518473, (float)0.99785892, (float)0.99946459,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)0.99946459, (float)0.99785892, (float)0.99518473,
	(float)0.99144486, (float)0.98664333, (float)0.98078528, (float)0.97387698,
	(float)0.96592583, (float)0.95694034, (float)0.94693013, (float)0.93590593,
	(float)0.92387953, (float)0.91086382, (float)0.89687274, (float)0.88192126,
	(float)0.86602540, (float)0.84920218, (float)0.83146961, (float)0.81284668,
	(float)0.79335334, (float)0.77301045, (float)0.75183981, (float)0.72986407,
	(float)0.70710678, (float)0.68359230, (float)0.65934582, (float)0.63439328,
	(float)0.60876143, (float)0.58247770, (float)0.55557023, (float)0.52806785,
	(float)0.50000000, (float)0.47139674, (float)0.44228869, (float)0.41270703,
	(float)0.38268343, (float)0.35225005, (float)0.32143947, (float)0.29028468,
	(float)0.25881905, (float)0.22707626, (float)0.19509032, (float)0.16289547,
	(float)0.13052619, (float)0.09801714, (float)0.06540313, (float)0.03271908 };

// hybrib Hanning & flat window
static const float kBlocks160w256[256] = {
	(float)0.00000000, (float)0.01636173, (float)0.03271908, (float)0.04906767,
	(float)0.06540313, (float)0.08172107, (float)0.09801714, (float)0.11428696,
	(float)0.13052619, (float)0.14673047, (float)0.16289547, (float)0.17901686,
	(float)0.19509032, (float)0.21111155, (float)0.22707626, (float)0.24298018,
	(float)0.25881905, (float)0.27458862, (float)0.29028468, (float)0.30590302,
	(float)0.32143947, (float)0.33688985, (float)0.35225005, (float)0.36751594,
	(float)0.38268343, (float)0.39774847, (float)0.41270703, (float)0.42755509,
	(float)0.44228869, (float)0.45690388, (float)0.47139674, (float)0.48576339,
	(float)0.50000000, (float)0.51410274, (float)0.52806785, (float)0.54189158,
	(float)0.55557023, (float)0.56910015, (float)0.58247770, (float)0.59569930,
	(float)0.60876143, (float)0.62166057, (float)0.63439328, (float)0.64695615,
	(float)0.65934582, (float)0.67155895, (float)0.68359230, (float)0.69544264,
	(float)0.70710678, (float)0.71858162, (float)0.72986407, (float)0.74095113,
	(float)0.75183981, (float)0.76252720, (float)0.77301045, (float)0.78328675,
	(float)0.79335334, (float)0.80320753, (float)0.81284668, (float)0.82226822,
	(float)0.83146961, (float)0.84044840, (float)0.84920218, (float)0.85772861,
	(float)0.86602540, (float)0.87409034, (float)0.88192126, (float)0.88951608,
	(float)0.89687274, (float)0.90398929, (float)0.91086382, (float)0.91749450,
	(float)0.92387953, (float)0.93001722, (float)0.93590593, (float)0.94154407,
	(float)0.94693013, (float)0.95206268, (float)0.95694034, (float)0.96156180,
	(float)0.96592583, (float)0.97003125, (float)0.97387698, (float)0.97746197,
	(float)0.98078528, (float)0.98384601, (float)0.98664333, (float)0.98917651,
	(float)0.99144486, (float)0.99344778, (float)0.99518473, (float)0.99665524,
	(float)0.99785892, (float)0.99879546, (float)0.99946459, (float)0.99986614,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)0.99986614, (float)0.99946459, (float)0.99879546,
	(float)0.99785892, (float)0.99665524, (float)0.99518473, (float)0.99344778,
	(float)0.99144486, (float)0.98917651, (float)0.98664333, (float)0.98384601,
	(float)0.98078528, (float)0.97746197, (float)0.97387698, (float)0.97003125,
	(float)0.96592583, (float)0.96156180, (float)0.95694034, (float)0.95206268,
	(float)0.94693013, (float)0.94154407, (float)0.93590593, (float)0.93001722,
	(float)0.92387953, (float)0.91749450, (float)0.91086382, (float)0.90398929,
	(float)0.89687274, (float)0.88951608, (float)0.88192126, (float)0.87409034,
	(float)0.86602540, (float)0.85772861, (float)0.84920218, (float)0.84044840,
	(float)0.83146961, (float)0.82226822, (float)0.81284668, (float)0.80320753,
	(float)0.79335334, (float)0.78328675, (float)0.77301045, (float)0.76252720,
	(float)0.75183981, (float)0.74095113, (float)0.72986407, (float)0.71858162,
	(float)0.70710678, (float)0.69544264, (float)0.68359230, (float)0.67155895,
	(float)0.65934582, (float)0.64695615, (float)0.63439328, (float)0.62166057,
	(float)0.60876143, (float)0.59569930, (float)0.58247770, (float)0.56910015,
	(float)0.55557023, (float)0.54189158, (float)0.52806785, (float)0.51410274,
	(float)0.50000000, (float)0.48576339, (float)0.47139674, (float)0.45690388,
	(float)0.44228869, (float)0.42755509, (float)0.41270703, (float)0.39774847,
	(float)0.38268343, (float)0.36751594, (float)0.35225005, (float)0.33688985,
	(float)0.32143947, (float)0.30590302, (float)0.29028468, (float)0.27458862,
	(float)0.25881905, (float)0.24298018, (float)0.22707626, (float)0.21111155,
	(float)0.19509032, (float)0.17901686, (float)0.16289547, (float)0.14673047,
	(float)0.13052619, (float)0.11428696, (float)0.09801714, (float)0.08172107,
	(float)0.06540313, (float)0.04906767, (float)0.03271908, (float)0.01636173 };

// hybrib Hanning & flat window: for 20ms
static const float kBlocks320w512[512] = {
	(float)0.00000000, (float)0.00818114, (float)0.01636173, (float)0.02454123,
	(float)0.03271908, (float)0.04089475, (float)0.04906767, (float)0.05723732,
	(float)0.06540313, (float)0.07356456, (float)0.08172107, (float)0.08987211,
	(float)0.09801714, (float)0.10615561, (float)0.11428696, (float)0.12241068,
	(float)0.13052619, (float)0.13863297, (float)0.14673047, (float)0.15481816,
	(float)0.16289547, (float)0.17096189, (float)0.17901686, (float)0.18705985,
	(float)0.19509032, (float)0.20310773, (float)0.21111155, (float)0.21910124,
	(float)0.22707626, (float)0.23503609, (float)0.24298018, (float)0.25090801,
	(float)0.25881905, (float)0.26671276, (float)0.27458862, (float)0.28244610,
	(float)0.29028468, (float)0.29810383, (float)0.30590302, (float)0.31368174,
	(float)0.32143947, (float)0.32917568, (float)0.33688985, (float)0.34458148,
	(float)0.35225005, (float)0.35989504, (float)0.36751594, (float)0.37511224,
	(float)0.38268343, (float)0.39022901, (float)0.39774847, (float)0.40524131,
	(float)0.41270703, (float)0.42014512, (float)0.42755509, (float)0.43493645,
	(float)0.44228869, (float)0.44961133, (float)0.45690388, (float)0.46416584,
	(float)0.47139674, (float)0.47859608, (float)0.48576339, (float)0.49289819,
	(float)0.50000000, (float)0.50706834, (float)0.51410274, (float)0.52110274,
	(float)0.52806785, (float)0.53499762, (float)0.54189158, (float)0.54874927,
	(float)0.55557023, (float)0.56235401, (float)0.56910015, (float)0.57580819,
	(float)0.58247770, (float)0.58910822, (float)0.59569930, (float)0.60225052,
	(float)0.60876143, (float)0.61523159, (float)0.62166057, (float)0.62804795,
	(float)0.63439328, (float)0.64069616, (float)0.64695615, (float)0.65317284,
	(float)0.65934582, (float)0.66547466, (float)0.67155895, (float)0.67759830,
	(float)0.68359230, (float)0.68954054, (float)0.69544264, (float)0.70129818,
	(float)0.70710678, (float)0.71286806, (float)0.71858162, (float)0.72424708,
	(float)0.72986407, (float)0.73543221, (float)0.74095113, (float)0.74642045,
	(float)0.75183981, (float)0.75720885, (float)0.76252720, (float)0.76779452,
	(float)0.77301045, (float)0.77817464, (float)0.78328675, (float)0.78834643,
	(float)0.79335334, (float)0.79830715, (float)0.80320753, (float)0.80805415,
	(float)0.81284668, (float)0.81758481, (float)0.82226822, (float)0.82689659,
	(float)0.83146961, (float)0.83598698, (float)0.84044840, (float)0.84485357,
	(float)0.84920218, (float)0.85349396, (float)0.85772861, (float)0.86190585,
	(float)0.86602540, (float)0.87008699, (float)0.87409034, (float)0.87803519,
	(float)0.88192126, (float)0.88574831, (float)0.88951608, (float)0.89322430,
	(float)0.89687274, (float)0.90046115, (float)0.90398929, (float)0.90745693,
	(float)0.91086382, (float)0.91420976, (float)0.91749450, (float)0.92071783,
	(float)0.92387953, (float)0.92697940, (float)0.93001722, (float)0.93299280,
	(float)0.93590593, (float)0.93875641, (float)0.94154407, (float)0.94426870,
	(float)0.94693013, (float)0.94952818, (float)0.95206268, (float)0.95453345,
	(float)0.95694034, (float)0.95928317, (float)0.96156180, (float)0.96377607,
	(float)0.96592583, (float)0.96801094, (float)0.97003125, (float)0.97198664,
	(float)0.97387698, (float)0.97570213, (float)0.97746197, (float)0.97915640,
	(float)0.98078528, (float)0.98234852, (float)0.98384601, (float)0.98527764,
	(float)0.98664333, (float)0.98794298, (float)0.98917651, (float)0.99034383,
	(float)0.99144486, (float)0.99247953, (float)0.99344778, (float)0.99434953,
	(float)0.99518473, (float)0.99595331, (float)0.99665524, (float)0.99729046,
	(float)0.99785892, (float)0.99836060, (float)0.99879546, (float)0.99916346,
	(float)0.99946459, (float)0.99969882, (float)0.99986614, (float)0.99996653,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)1.00000000, (float)1.00000000, (float)1.00000000,
	(float)1.00000000, (float)0.99996653, (float)0.99986614, (float)0.99969882,
	(float)0.99946459, (float)0.99916346, (float)0.99879546, (float)0.99836060,
	(float)0.99785892, (float)0.99729046, (float)0.99665524, (float)0.99595331,
	(float)0.99518473, (float)0.99434953, (float)0.99344778, (float)0.99247953,
	(float)0.99144486, (float)0.99034383, (float)0.98917651, (float)0.98794298,
	(float)0.98664333, (float)0.98527764, (float)0.98384601, (float)0.98234852,
	(float)0.98078528, (float)0.97915640, (float)0.97746197, (float)0.97570213,
	(float)0.97387698, (float)0.97198664, (float)0.97003125, (float)0.96801094,
	(float)0.96592583, (float)0.96377607, (float)0.96156180, (float)0.95928317,
	(float)0.95694034, (float)0.95453345, (float)0.95206268, (float)0.94952818,
	(float)0.94693013, (float)0.94426870, (float)0.94154407, (float)0.93875641,
	(float)0.93590593, (float)0.93299280, (float)0.93001722, (float)0.92697940,
	(float)0.92387953, (float)0.92071783, (float)0.91749450, (float)0.91420976,
	(float)0.91086382, (float)0.90745693, (float)0.90398929, (float)0.90046115,
	(float)0.89687274, (float)0.89322430, (float)0.88951608, (float)0.88574831,
	(float)0.88192126, (float)0.87803519, (float)0.87409034, (float)0.87008699,
	(float)0.86602540, (float)0.86190585, (float)0.85772861, (float)0.85349396,
	(float)0.84920218, (float)0.84485357, (float)0.84044840, (float)0.83598698,
	(float)0.83146961, (float)0.82689659, (float)0.82226822, (float)0.81758481,
	(float)0.81284668, (float)0.80805415, (float)0.80320753, (float)0.79830715,
	(float)0.79335334, (float)0.78834643, (float)0.78328675, (float)0.77817464,
	(float)0.77301045, (float)0.76779452, (float)0.76252720, (float)0.75720885,
	(float)0.75183981, (float)0.74642045, (float)0.74095113, (float)0.73543221,
	(float)0.72986407, (float)0.72424708, (float)0.71858162, (float)0.71286806,
	(float)0.70710678, (float)0.70129818, (float)0.69544264, (float)0.68954054,
	(float)0.68359230, (float)0.67759830, (float)0.67155895, (float)0.66547466,
	(float)0.65934582, (float)0.65317284, (float)0.64695615, (float)0.64069616,
	(float)0.63439328, (float)0.62804795, (float)0.62166057, (float)0.61523159,
	(float)0.60876143, (float)0.60225052, (float)0.59569930, (float)0.58910822,
	(float)0.58247770, (float)0.57580819, (float)0.56910015, (float)0.56235401,
	(float)0.55557023, (float)0.54874927, (float)0.54189158, (float)0.53499762,
	(float)0.52806785, (float)0.52110274, (float)0.51410274, (float)0.50706834,
	(float)0.50000000, (float)0.49289819, (float)0.48576339, (float)0.47859608,
	(float)0.47139674, (float)0.46416584, (float)0.45690388, (float)0.44961133,
	(float)0.44228869, (float)0.43493645, (float)0.42755509, (float)0.42014512,
	(float)0.41270703, (float)0.40524131, (float)0.39774847, (float)0.39022901,
	(float)0.38268343, (float)0.37511224, (float)0.36751594, (float)0.35989504,
	(float)0.35225005, (float)0.34458148, (float)0.33688985, (float)0.32917568,
	(float)0.32143947, (float)0.31368174, (float)0.30590302, (float)0.29810383,
	(float)0.29028468, (float)0.28244610, (float)0.27458862, (float)0.26671276,
	(float)0.25881905, (float)0.25090801, (float)0.24298018, (float)0.23503609,
	(float)0.22707626, (float)0.21910124, (float)0.21111155, (float)0.20310773,
	(float)0.19509032, (float)0.18705985, (float)0.17901686, (float)0.17096189,
	(float)0.16289547, (float)0.15481816, (float)0.14673047, (float)0.13863297,
	(float)0.13052619, (float)0.12241068, (float)0.11428696, (float)0.10615561,
	(float)0.09801714, (float)0.08987211, (float)0.08172107, (float)0.07356456,
	(float)0.06540313, (float)0.05723732, (float)0.04906767, (float)0.04089475,
	(float)0.03271908, (float)0.02454123, (float)0.01636173, (float)0.00818114 };

// Hanning window: for 15ms at 16kHz with symmetric zeros
static const float kBlocks240w512[512] = {
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00654494, (float)0.01308960, (float)0.01963369,
	(float)0.02617695, (float)0.03271908, (float)0.03925982, (float)0.04579887,
	(float)0.05233596, (float)0.05887080, (float)0.06540313, (float)0.07193266,
	(float)0.07845910, (float)0.08498218, (float)0.09150162, (float)0.09801714,
	(float)0.10452846, (float)0.11103531, (float)0.11753740, (float)0.12403446,
	(float)0.13052620, (float)0.13701233, (float)0.14349262, (float)0.14996676,
	(float)0.15643448, (float)0.16289547, (float)0.16934951, (float)0.17579629,
	(float)0.18223552, (float)0.18866697, (float)0.19509032, (float)0.20150533,
	(float)0.20791170, (float)0.21430916, (float)0.22069745, (float)0.22707628,
	(float)0.23344538, (float)0.23980446, (float)0.24615330, (float)0.25249159,
	(float)0.25881904, (float)0.26513544, (float)0.27144045, (float)0.27773386,
	(float)0.28401536, (float)0.29028466, (float)0.29654160, (float)0.30278578,
	(float)0.30901700, (float)0.31523499, (float)0.32143945, (float)0.32763019,
	(float)0.33380687, (float)0.33996925, (float)0.34611708, (float)0.35225007,
	(float)0.35836795, (float)0.36447051, (float)0.37055743, (float)0.37662852,
	(float)0.38268346, (float)0.38872197, (float)0.39474389, (float)0.40074885,
	(float)0.40673664, (float)0.41270703, (float)0.41865975, (float)0.42459452,
	(float)0.43051112, (float)0.43640924, (float)0.44228873, (float)0.44814920,
	(float)0.45399052, (float)0.45981237, (float)0.46561453, (float)0.47139674,
	(float)0.47715878, (float)0.48290035, (float)0.48862126, (float)0.49432120,
	(float)0.50000000, (float)0.50565743, (float)0.51129311, (float)0.51690692,
	(float)0.52249855, (float)0.52806789, (float)0.53361452, (float)0.53913832,
	(float)0.54463905, (float)0.55011642, (float)0.55557024, (float)0.56100029,
	(float)0.56640625, (float)0.57178795, (float)0.57714522, (float)0.58247769,
	(float)0.58778524, (float)0.59306765, (float)0.59832460, (float)0.60355598,
	(float)0.60876143, (float)0.61394083, (float)0.61909395, (float)0.62422055,
	(float)0.62932038, (float)0.63439333, (float)0.63943899, (float)0.64445734,
	(float)0.64944810, (float)0.65441096, (float)0.65934587, (float)0.66425246,
	(float)0.66913062, (float)0.67398012, (float)0.67880076, (float)0.68359232,
	(float)0.68835455, (float)0.69308740, (float)0.69779050, (float)0.70246369,
	(float)0.70710677, (float)0.71171963, (float)0.71630198, (float)0.72085363,
	(float)0.72537440, (float)0.72986406, (float)0.73432255, (float)0.73874950,
	(float)0.74314487, (float)0.74750835, (float)0.75183982, (float)0.75613910,
	(float)0.76040596, (float)0.76464027, (float)0.76884186, (float)0.77301043,
	(float)0.77714598, (float)0.78124821, (float)0.78531694, (float)0.78935206,
	(float)0.79335338, (float)0.79732066, (float)0.80125386, (float)0.80515265,
	(float)0.80901700, (float)0.81284672, (float)0.81664157, (float)0.82040149,
	(float)0.82412618, (float)0.82781565, (float)0.83146966, (float)0.83508795,
	(float)0.83867061, (float)0.84221727, (float)0.84572780, (float)0.84920216,
	(float)0.85264021, (float)0.85604161, (float)0.85940641, (float)0.86273444,
	(float)0.86602545, (float)0.86927933, (float)0.87249607, (float)0.87567532,
	(float)0.87881714, (float)0.88192129, (float)0.88498765, (float)0.88801610,
	(float)0.89100653, (float)0.89395881, (float)0.89687276, (float)0.89974827,
	(float)0.90258533, (float)0.90538365, (float)0.90814316, (float)0.91086388,
	(float)0.91354549, (float)0.91618794, (float)0.91879123, (float)0.92135513,
	(float)0.92387950, (float)0.92636442, (float)0.92880958, (float)0.93121493,
	(float)0.93358046, (float)0.93590593, (float)0.93819135, (float)0.94043654,
	(float)0.94264150, (float)0.94480604, (float)0.94693011, (float)0.94901365,
	(float)0.95105654, (float)0.95305866, (float)0.95501995, (float)0.95694035,
	(float)0.95881975, (float)0.96065807, (float)0.96245527, (float)0.96421117,
	(float)0.96592581, (float)0.96759909, (float)0.96923089, (float)0.97082120,
	(float)0.97236991, (float)0.97387701, (float)0.97534233, (float)0.97676587,
	(float)0.97814763, (float)0.97948742, (float)0.98078531, (float)0.98204112,
	(float)0.98325491, (float)0.98442656, (float)0.98555607, (float)0.98664331,
	(float)0.98768836, (float)0.98869103, (float)0.98965138, (float)0.99056935,
	(float)0.99144489, (float)0.99227792, (float)0.99306846, (float)0.99381649,
	(float)0.99452192, (float)0.99518472, (float)0.99580491, (float)0.99638247,
	(float)0.99691731, (float)0.99740952, (float)0.99785894, (float)0.99826562,
	(float)0.99862951, (float)0.99895066, (float)0.99922901, (float)0.99946457,
	(float)0.99965733, (float)0.99980724, (float)0.99991435, (float)0.99997860,
	(float)1.00000000, (float)0.99997860, (float)0.99991435, (float)0.99980724,
	(float)0.99965733, (float)0.99946457, (float)0.99922901, (float)0.99895066,
	(float)0.99862951, (float)0.99826562, (float)0.99785894, (float)0.99740946,
	(float)0.99691731, (float)0.99638247, (float)0.99580491, (float)0.99518472,
	(float)0.99452192, (float)0.99381644, (float)0.99306846, (float)0.99227792,
	(float)0.99144489, (float)0.99056935, (float)0.98965138, (float)0.98869103,
	(float)0.98768836, (float)0.98664331, (float)0.98555607, (float)0.98442656,
	(float)0.98325491, (float)0.98204112, (float)0.98078525, (float)0.97948742,
	(float)0.97814757, (float)0.97676587, (float)0.97534227, (float)0.97387695,
	(float)0.97236991, (float)0.97082120, (float)0.96923089, (float)0.96759909,
	(float)0.96592581, (float)0.96421117, (float)0.96245521, (float)0.96065807,
	(float)0.95881969, (float)0.95694029, (float)0.95501995, (float)0.95305860,
	(float)0.95105648, (float)0.94901365, (float)0.94693011, (float)0.94480604,
	(float)0.94264150, (float)0.94043654, (float)0.93819129, (float)0.93590593,
	(float)0.93358046, (float)0.93121493, (float)0.92880952, (float)0.92636436,
	(float)0.92387950, (float)0.92135507, (float)0.91879123, (float)0.91618794,
	(float)0.91354543, (float)0.91086382, (float)0.90814310, (float)0.90538365,
	(float)0.90258527, (float)0.89974827, (float)0.89687276, (float)0.89395875,
	(float)0.89100647, (float)0.88801610, (float)0.88498759, (float)0.88192123,
	(float)0.87881714, (float)0.87567532, (float)0.87249595, (float)0.86927933,
	(float)0.86602539, (float)0.86273432, (float)0.85940641, (float)0.85604161,
	(float)0.85264009, (float)0.84920216, (float)0.84572780, (float)0.84221715,
	(float)0.83867055, (float)0.83508795, (float)0.83146954, (float)0.82781565,
	(float)0.82412612, (float)0.82040137, (float)0.81664157, (float)0.81284660,
	(float)0.80901700, (float)0.80515265, (float)0.80125374, (float)0.79732066,
	(float)0.79335332, (float)0.78935200, (float)0.78531694, (float)0.78124815,
	(float)0.77714586, (float)0.77301049, (float)0.76884180, (float)0.76464021,
	(float)0.76040596, (float)0.75613904, (float)0.75183970, (float)0.74750835,
	(float)0.74314481, (float)0.73874938, (float)0.73432249, (float)0.72986400,
	(float)0.72537428, (float)0.72085363, (float)0.71630186, (float)0.71171951,
	(float)0.70710677, (float)0.70246363, (float)0.69779032, (float)0.69308734,
	(float)0.68835449, (float)0.68359220, (float)0.67880070, (float)0.67398006,
	(float)0.66913044, (float)0.66425240, (float)0.65934575, (float)0.65441096,
	(float)0.64944804, (float)0.64445722, (float)0.63943905, (float)0.63439327,
	(float)0.62932026, (float)0.62422055, (float)0.61909389, (float)0.61394072,
	(float)0.60876143, (float)0.60355592, (float)0.59832448, (float)0.59306765,
	(float)0.58778518, (float)0.58247757, (float)0.57714522, (float)0.57178789,
	(float)0.56640613, (float)0.56100023, (float)0.55557019, (float)0.55011630,
	(float)0.54463905, (float)0.53913826, (float)0.53361434, (float)0.52806783,
	(float)0.52249849, (float)0.51690674, (float)0.51129305, (float)0.50565726,
	(float)0.50000006, (float)0.49432117, (float)0.48862115, (float)0.48290038,
	(float)0.47715873, (float)0.47139663, (float)0.46561456, (float)0.45981231,
	(float)0.45399037, (float)0.44814920, (float)0.44228864, (float)0.43640912,
	(float)0.43051112, (float)0.42459446, (float)0.41865960, (float)0.41270703,
	(float)0.40673658, (float)0.40074870, (float)0.39474386, (float)0.38872188,
	(float)0.38268328, (float)0.37662849, (float)0.37055734, (float)0.36447033,
	(float)0.35836792, (float)0.35224995, (float)0.34611690, (float)0.33996922,
	(float)0.33380675, (float)0.32763001, (float)0.32143945, (float)0.31523487,
	(float)0.30901679, (float)0.30278572, (float)0.29654145, (float)0.29028472,
	(float)0.28401530, (float)0.27773371, (float)0.27144048, (float)0.26513538,
	(float)0.25881892, (float)0.25249159, (float)0.24615324, (float)0.23980433,
	(float)0.23344538, (float)0.22707619, (float)0.22069728, (float)0.21430916,
	(float)0.20791161, (float)0.20150517, (float)0.19509031, (float)0.18866688,
	(float)0.18223536, (float)0.17579627, (float)0.16934940, (float)0.16289529,
	(float)0.15643445, (float)0.14996666, (float)0.14349243, (float)0.13701232,
	(float)0.13052608, (float)0.12403426, (float)0.11753736, (float)0.11103519,
	(float)0.10452849, (float)0.09801710, (float)0.09150149, (float)0.08498220,
	(float)0.07845904, (float)0.07193252, (float)0.06540315, (float)0.05887074,
	(float)0.05233581, (float)0.04579888, (float)0.03925974, (float)0.03271893,
	(float)0.02617695, (float)0.01963361, (float)0.01308943, (float)0.00654493,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000 };

// Hanning window: for 30ms with 1024 fft with symmetric zeros at 16kHz
static const float kBlocks480w1024[1024] = {
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00327249, (float)0.00654494, (float)0.00981732,
	(float)0.01308960, (float)0.01636173, (float)0.01963369, (float)0.02290544,
	(float)0.02617695, (float)0.02944817, (float)0.03271908, (float)0.03598964,
	(float)0.03925982, (float)0.04252957, (float)0.04579887, (float)0.04906768,
	(float)0.05233596, (float)0.05560368, (float)0.05887080, (float)0.06213730,
	(float)0.06540313, (float)0.06866825, (float)0.07193266, (float)0.07519628,
	(float)0.07845910, (float)0.08172107, (float)0.08498218, (float)0.08824237,
	(float)0.09150162, (float)0.09475989, (float)0.09801714, (float)0.10127335,
	(float)0.10452846, (float)0.10778246, (float)0.11103531, (float)0.11428697,
	(float)0.11753740, (float)0.12078657, (float)0.12403446, (float)0.12728101,
	(float)0.13052620, (float)0.13376999, (float)0.13701233, (float)0.14025325,
	(float)0.14349262, (float)0.14673047, (float)0.14996676, (float)0.15320145,
	(float)0.15643448, (float)0.15966582, (float)0.16289547, (float)0.16612339,
	(float)0.16934951, (float)0.17257382, (float)0.17579629, (float)0.17901687,
	(float)0.18223552, (float)0.18545224, (float)0.18866697, (float)0.19187967,
	(float)0.19509032, (float)0.19829889, (float)0.20150533, (float)0.20470962,
	(float)0.20791170, (float)0.21111156, (float)0.21430916, (float)0.21750447,
	(float)0.22069745, (float)0.22388805, (float)0.22707628, (float)0.23026206,
	(float)0.23344538, (float)0.23662618, (float)0.23980446, (float)0.24298020,
	(float)0.24615330, (float)0.24932377, (float)0.25249159, (float)0.25565669,
	(float)0.25881904, (float)0.26197866, (float)0.26513544, (float)0.26828939,
	(float)0.27144045, (float)0.27458861, (float)0.27773386, (float)0.28087610,
	(float)0.28401536, (float)0.28715158, (float)0.29028466, (float)0.29341471,
	(float)0.29654160, (float)0.29966527, (float)0.30278578, (float)0.30590302,
	(float)0.30901700, (float)0.31212768, (float)0.31523499, (float)0.31833893,
	(float)0.32143945, (float)0.32453656, (float)0.32763019, (float)0.33072028,
	(float)0.33380687, (float)0.33688986, (float)0.33996925, (float)0.34304500,
	(float)0.34611708, (float)0.34918544, (float)0.35225007, (float)0.35531089,
	(float)0.35836795, (float)0.36142117, (float)0.36447051, (float)0.36751595,
	(float)0.37055743, (float)0.37359497, (float)0.37662852, (float)0.37965801,
	(float)0.38268346, (float)0.38570479, (float)0.38872197, (float)0.39173502,
	(float)0.39474389, (float)0.39774847, (float)0.40074885, (float)0.40374491,
	(float)0.40673664, (float)0.40972406, (float)0.41270703, (float)0.41568562,
	(float)0.41865975, (float)0.42162940, (float)0.42459452, (float)0.42755508,
	(float)0.43051112, (float)0.43346250, (float)0.43640924, (float)0.43935132,
	(float)0.44228873, (float)0.44522133, (float)0.44814920, (float)0.45107228,
	(float)0.45399052, (float)0.45690390, (float)0.45981237, (float)0.46271592,
	(float)0.46561453, (float)0.46850815, (float)0.47139674, (float)0.47428030,
	(float)0.47715878, (float)0.48003215, (float)0.48290035, (float)0.48576337,
	(float)0.48862126, (float)0.49147385, (float)0.49432120, (float)0.49716330,
	(float)0.50000000, (float)0.50283140, (float)0.50565743, (float)0.50847799,
	(float)0.51129311, (float)0.51410276, (float)0.51690692, (float)0.51970553,
	(float)0.52249855, (float)0.52528602, (float)0.52806789, (float)0.53084403,
	(float)0.53361452, (float)0.53637928, (float)0.53913832, (float)0.54189163,
	(float)0.54463905, (float)0.54738063, (float)0.55011642, (float)0.55284631,
	(float)0.55557024, (float)0.55828828, (float)0.56100029, (float)0.56370628,
	(float)0.56640625, (float)0.56910014, (float)0.57178795, (float)0.57446963,
	(float)0.57714522, (float)0.57981455, (float)0.58247769, (float)0.58513463,
	(float)0.58778524, (float)0.59042960, (float)0.59306765, (float)0.59569931,
	(float)0.59832460, (float)0.60094351, (float)0.60355598, (float)0.60616195,
	(float)0.60876143, (float)0.61135441, (float)0.61394083, (float)0.61652070,
	(float)0.61909395, (float)0.62166059, (float)0.62422055, (float)0.62677383,
	(float)0.62932038, (float)0.63186020, (float)0.63439333, (float)0.63691956,
	(float)0.63943899, (float)0.64195162, (float)0.64445734, (float)0.64695615,
	(float)0.64944810, (float)0.65193301, (float)0.65441096, (float)0.65688187,
	(float)0.65934587, (float)0.66180271, (float)0.66425246, (float)0.66669512,
	(float)0.66913062, (float)0.67155898, (float)0.67398012, (float)0.67639405,
	(float)0.67880076, (float)0.68120021, (float)0.68359232, (float)0.68597710,
	(float)0.68835455, (float)0.69072467, (float)0.69308740, (float)0.69544262,
	(float)0.69779050, (float)0.70013082, (float)0.70246369, (float)0.70478904,
	(float)0.70710677, (float)0.70941699, (float)0.71171963, (float)0.71401459,
	(float)0.71630198, (float)0.71858168, (float)0.72085363, (float)0.72311789,
	(float)0.72537440, (float)0.72762316, (float)0.72986406, (float)0.73209721,
	(float)0.73432255, (float)0.73653996, (float)0.73874950, (float)0.74095118,
	(float)0.74314487, (float)0.74533057, (float)0.74750835, (float)0.74967808,
	(float)0.75183982, (float)0.75399351, (float)0.75613910, (float)0.75827658,
	(float)0.76040596, (float)0.76252723, (float)0.76464027, (float)0.76674515,
	(float)0.76884186, (float)0.77093029, (float)0.77301043, (float)0.77508241,
	(float)0.77714598, (float)0.77920127, (float)0.78124821, (float)0.78328675,
	(float)0.78531694, (float)0.78733873, (float)0.78935206, (float)0.79135692,
	(float)0.79335338, (float)0.79534125, (float)0.79732066, (float)0.79929149,
	(float)0.80125386, (float)0.80320752, (float)0.80515265, (float)0.80708915,
	(float)0.80901700, (float)0.81093621, (float)0.81284672, (float)0.81474853,
	(float)0.81664157, (float)0.81852591, (float)0.82040149, (float)0.82226825,
	(float)0.82412618, (float)0.82597536, (float)0.82781565, (float)0.82964706,
	(float)0.83146966, (float)0.83328325, (float)0.83508795, (float)0.83688378,
	(float)0.83867061, (float)0.84044838, (float)0.84221727, (float)0.84397703,
	(float)0.84572780, (float)0.84746957, (float)0.84920216, (float)0.85092574,
	(float)0.85264021, (float)0.85434544, (float)0.85604161, (float)0.85772866,
	(float)0.85940641, (float)0.86107504, (float)0.86273444, (float)0.86438453,
	(float)0.86602545, (float)0.86765707, (float)0.86927933, (float)0.87089235,
	(float)0.87249607, (float)0.87409031, (float)0.87567532, (float)0.87725097,
	(float)0.87881714, (float)0.88037390, (float)0.88192129, (float)0.88345921,
	(float)0.88498765, (float)0.88650668, (float)0.88801610, (float)0.88951612,
	(float)0.89100653, (float)0.89248741, (float)0.89395881, (float)0.89542055,
	(float)0.89687276, (float)0.89831537, (float)0.89974827, (float)0.90117162,
	(float)0.90258533, (float)0.90398932, (float)0.90538365, (float)0.90676826,
	(float)0.90814316, (float)0.90950841, (float)0.91086388, (float)0.91220951,
	(float)0.91354549, (float)0.91487163, (float)0.91618794, (float)0.91749454,
	(float)0.91879123, (float)0.92007810, (float)0.92135513, (float)0.92262226,
	(float)0.92387950, (float)0.92512691, (float)0.92636442, (float)0.92759192,
	(float)0.92880958, (float)0.93001723, (float)0.93121493, (float)0.93240267,
	(float)0.93358046, (float)0.93474817, (float)0.93590593, (float)0.93705362,
	(float)0.93819135, (float)0.93931901, (float)0.94043654, (float)0.94154406,
	(float)0.94264150, (float)0.94372880, (float)0.94480604, (float)0.94587320,
	(float)0.94693011, (float)0.94797695, (float)0.94901365, (float)0.95004016,
	(float)0.95105654, (float)0.95206273, (float)0.95305866, (float)0.95404440,
	(float)0.95501995, (float)0.95598525, (float)0.95694035, (float)0.95788521,
	(float)0.95881975, (float)0.95974404, (float)0.96065807, (float)0.96156180,
	(float)0.96245527, (float)0.96333838, (float)0.96421117, (float)0.96507370,
	(float)0.96592581, (float)0.96676767, (float)0.96759909, (float)0.96842021,
	(float)0.96923089, (float)0.97003126, (float)0.97082120, (float)0.97160077,
	(float)0.97236991, (float)0.97312868, (float)0.97387701, (float)0.97461486,
	(float)0.97534233, (float)0.97605932, (float)0.97676587, (float)0.97746199,
	(float)0.97814763, (float)0.97882277, (float)0.97948742, (float)0.98014158,
	(float)0.98078531, (float)0.98141843, (float)0.98204112, (float)0.98265332,
	(float)0.98325491, (float)0.98384601, (float)0.98442656, (float)0.98499662,
	(float)0.98555607, (float)0.98610497, (float)0.98664331, (float)0.98717111,
	(float)0.98768836, (float)0.98819500, (float)0.98869103, (float)0.98917651,
	(float)0.98965138, (float)0.99011570, (float)0.99056935, (float)0.99101239,
	(float)0.99144489, (float)0.99186671, (float)0.99227792, (float)0.99267852,
	(float)0.99306846, (float)0.99344778, (float)0.99381649, (float)0.99417448,
	(float)0.99452192, (float)0.99485862, (float)0.99518472, (float)0.99550015,
	(float)0.99580491, (float)0.99609905, (float)0.99638247, (float)0.99665523,
	(float)0.99691731, (float)0.99716878, (float)0.99740952, (float)0.99763954,
	(float)0.99785894, (float)0.99806762, (float)0.99826562, (float)0.99845290,
	(float)0.99862951, (float)0.99879545, (float)0.99895066, (float)0.99909520,
	(float)0.99922901, (float)0.99935216, (float)0.99946457, (float)0.99956632,
	(float)0.99965733, (float)0.99973762, (float)0.99980724, (float)0.99986613,
	(float)0.99991435, (float)0.99995178, (float)0.99997860, (float)0.99999464,
	(float)1.00000000, (float)0.99999464, (float)0.99997860, (float)0.99995178,
	(float)0.99991435, (float)0.99986613, (float)0.99980724, (float)0.99973762,
	(float)0.99965733, (float)0.99956632, (float)0.99946457, (float)0.99935216,
	(float)0.99922901, (float)0.99909520, (float)0.99895066, (float)0.99879545,
	(float)0.99862951, (float)0.99845290, (float)0.99826562, (float)0.99806762,
	(float)0.99785894, (float)0.99763954, (float)0.99740946, (float)0.99716872,
	(float)0.99691731, (float)0.99665523, (float)0.99638247, (float)0.99609905,
	(float)0.99580491, (float)0.99550015, (float)0.99518472, (float)0.99485862,
	(float)0.99452192, (float)0.99417448, (float)0.99381644, (float)0.99344778,
	(float)0.99306846, (float)0.99267852, (float)0.99227792, (float)0.99186671,
	(float)0.99144489, (float)0.99101239, (float)0.99056935, (float)0.99011564,
	(float)0.98965138, (float)0.98917651, (float)0.98869103, (float)0.98819494,
	(float)0.98768836, (float)0.98717111, (float)0.98664331, (float)0.98610497,
	(float)0.98555607, (float)0.98499656, (float)0.98442656, (float)0.98384601,
	(float)0.98325491, (float)0.98265326, (float)0.98204112, (float)0.98141843,
	(float)0.98078525, (float)0.98014158, (float)0.97948742, (float)0.97882277,
	(float)0.97814757, (float)0.97746193, (float)0.97676587, (float)0.97605932,
	(float)0.97534227, (float)0.97461486, (float)0.97387695, (float)0.97312862,
	(float)0.97236991, (float)0.97160077, (float)0.97082120, (float)0.97003126,
	(float)0.96923089, (float)0.96842015, (float)0.96759909, (float)0.96676761,
	(float)0.96592581, (float)0.96507365, (float)0.96421117, (float)0.96333838,
	(float)0.96245521, (float)0.96156180, (float)0.96065807, (float)0.95974404,
	(float)0.95881969, (float)0.95788515, (float)0.95694029, (float)0.95598525,
	(float)0.95501995, (float)0.95404440, (float)0.95305860, (float)0.95206267,
	(float)0.95105648, (float)0.95004016, (float)0.94901365, (float)0.94797695,
	(float)0.94693011, (float)0.94587314, (float)0.94480604, (float)0.94372880,
	(float)0.94264150, (float)0.94154406, (float)0.94043654, (float)0.93931895,
	(float)0.93819129, (float)0.93705362, (float)0.93590593, (float)0.93474817,
	(float)0.93358046, (float)0.93240267, (float)0.93121493, (float)0.93001723,
	(float)0.92880952, (float)0.92759192, (float)0.92636436, (float)0.92512691,
	(float)0.92387950, (float)0.92262226, (float)0.92135507, (float)0.92007804,
	(float)0.91879123, (float)0.91749448, (float)0.91618794, (float)0.91487157,
	(float)0.91354543, (float)0.91220951, (float)0.91086382, (float)0.90950835,
	(float)0.90814310, (float)0.90676820, (float)0.90538365, (float)0.90398932,
	(float)0.90258527, (float)0.90117157, (float)0.89974827, (float)0.89831525,
	(float)0.89687276, (float)0.89542055, (float)0.89395875, (float)0.89248741,
	(float)0.89100647, (float)0.88951600, (float)0.88801610, (float)0.88650662,
	(float)0.88498759, (float)0.88345915, (float)0.88192123, (float)0.88037384,
	(float)0.87881714, (float)0.87725091, (float)0.87567532, (float)0.87409031,
	(float)0.87249595, (float)0.87089223, (float)0.86927933, (float)0.86765701,
	(float)0.86602539, (float)0.86438447, (float)0.86273432, (float)0.86107504,
	(float)0.85940641, (float)0.85772860, (float)0.85604161, (float)0.85434544,
	(float)0.85264009, (float)0.85092574, (float)0.84920216, (float)0.84746951,
	(float)0.84572780, (float)0.84397697, (float)0.84221715, (float)0.84044844,
	(float)0.83867055, (float)0.83688372, (float)0.83508795, (float)0.83328319,
	(float)0.83146954, (float)0.82964706, (float)0.82781565, (float)0.82597530,
	(float)0.82412612, (float)0.82226813, (float)0.82040137, (float)0.81852591,
	(float)0.81664157, (float)0.81474847, (float)0.81284660, (float)0.81093609,
	(float)0.80901700, (float)0.80708915, (float)0.80515265, (float)0.80320752,
	(float)0.80125374, (float)0.79929143, (float)0.79732066, (float)0.79534125,
	(float)0.79335332, (float)0.79135686, (float)0.78935200, (float)0.78733861,
	(float)0.78531694, (float)0.78328675, (float)0.78124815, (float)0.77920121,
	(float)0.77714586, (float)0.77508223, (float)0.77301049, (float)0.77093029,
	(float)0.76884180, (float)0.76674509, (float)0.76464021, (float)0.76252711,
	(float)0.76040596, (float)0.75827658, (float)0.75613904, (float)0.75399339,
	(float)0.75183970, (float)0.74967796, (float)0.74750835, (float)0.74533057,
	(float)0.74314481, (float)0.74095106, (float)0.73874938, (float)0.73653996,
	(float)0.73432249, (float)0.73209721, (float)0.72986400, (float)0.72762305,
	(float)0.72537428, (float)0.72311789, (float)0.72085363, (float)0.71858162,
	(float)0.71630186, (float)0.71401453, (float)0.71171951, (float)0.70941705,
	(float)0.70710677, (float)0.70478898, (float)0.70246363, (float)0.70013070,
	(float)0.69779032, (float)0.69544268, (float)0.69308734, (float)0.69072461,
	(float)0.68835449, (float)0.68597704, (float)0.68359220, (float)0.68120021,
	(float)0.67880070, (float)0.67639399, (float)0.67398006, (float)0.67155886,
	(float)0.66913044, (float)0.66669512, (float)0.66425240, (float)0.66180259,
	(float)0.65934575, (float)0.65688181, (float)0.65441096, (float)0.65193301,
	(float)0.64944804, (float)0.64695609, (float)0.64445722, (float)0.64195150,
	(float)0.63943905, (float)0.63691956, (float)0.63439327, (float)0.63186014,
	(float)0.62932026, (float)0.62677372, (float)0.62422055, (float)0.62166059,
	(float)0.61909389, (float)0.61652064, (float)0.61394072, (float)0.61135429,
	(float)0.60876143, (float)0.60616189, (float)0.60355592, (float)0.60094339,
	(float)0.59832448, (float)0.59569913, (float)0.59306765, (float)0.59042960,
	(float)0.58778518, (float)0.58513451, (float)0.58247757, (float)0.57981461,
	(float)0.57714522, (float)0.57446963, (float)0.57178789, (float)0.56910002,
	(float)0.56640613, (float)0.56370628, (float)0.56100023, (float)0.55828822,
	(float)0.55557019, (float)0.55284619, (float)0.55011630, (float)0.54738069,
	(float)0.54463905, (float)0.54189152, (float)0.53913826, (float)0.53637916,
	(float)0.53361434, (float)0.53084403, (float)0.52806783, (float)0.52528596,
	(float)0.52249849, (float)0.51970541, (float)0.51690674, (float)0.51410276,
	(float)0.51129305, (float)0.50847787, (float)0.50565726, (float)0.50283122,
	(float)0.50000006, (float)0.49716327, (float)0.49432117, (float)0.49147379,
	(float)0.48862115, (float)0.48576325, (float)0.48290038, (float)0.48003212,
	(float)0.47715873, (float)0.47428021, (float)0.47139663, (float)0.46850798,
	(float)0.46561456, (float)0.46271589, (float)0.45981231, (float)0.45690379,
	(float)0.45399037, (float)0.45107210, (float)0.44814920, (float)0.44522130,
	(float)0.44228864, (float)0.43935123, (float)0.43640912, (float)0.43346232,
	(float)0.43051112, (float)0.42755505, (float)0.42459446, (float)0.42162928,
	(float)0.41865960, (float)0.41568545, (float)0.41270703, (float)0.40972400,
	(float)0.40673658, (float)0.40374479, (float)0.40074870, (float)0.39774850,
	(float)0.39474386, (float)0.39173496, (float)0.38872188, (float)0.38570464,
	(float)0.38268328, (float)0.37965804, (float)0.37662849, (float)0.37359491,
	(float)0.37055734, (float)0.36751580, (float)0.36447033, (float)0.36142117,
	(float)0.35836792, (float)0.35531086, (float)0.35224995, (float)0.34918529,
	(float)0.34611690, (float)0.34304500, (float)0.33996922, (float)0.33688980,
	(float)0.33380675, (float)0.33072016, (float)0.32763001, (float)0.32453656,
	(float)0.32143945, (float)0.31833887, (float)0.31523487, (float)0.31212750,
	(float)0.30901679, (float)0.30590302, (float)0.30278572, (float)0.29966521,
	(float)0.29654145, (float)0.29341453, (float)0.29028472, (float)0.28715155,
	(float)0.28401530, (float)0.28087601, (float)0.27773371, (float)0.27458847,
	(float)0.27144048, (float)0.26828936, (float)0.26513538, (float)0.26197854,
	(float)0.25881892, (float)0.25565651, (float)0.25249159, (float)0.24932374,
	(float)0.24615324, (float)0.24298008, (float)0.23980433, (float)0.23662600,
	(float)0.23344538, (float)0.23026201, (float)0.22707619, (float)0.22388794,
	(float)0.22069728, (float)0.21750426, (float)0.21430916, (float)0.21111152,
	(float)0.20791161, (float)0.20470949, (float)0.20150517, (float)0.19829892,
	(float)0.19509031, (float)0.19187963, (float)0.18866688, (float)0.18545210,
	(float)0.18223536, (float)0.17901689, (float)0.17579627, (float)0.17257376,
	(float)0.16934940, (float)0.16612324, (float)0.16289529, (float)0.15966584,
	(float)0.15643445, (float)0.15320137, (float)0.14996666, (float)0.14673033,
	(float)0.14349243, (float)0.14025325, (float)0.13701232, (float)0.13376991,
	(float)0.13052608, (float)0.12728085, (float)0.12403426, (float)0.12078657,
	(float)0.11753736, (float)0.11428688, (float)0.11103519, (float)0.10778230,
	(float)0.10452849, (float)0.10127334, (float)0.09801710, (float)0.09475980,
	(float)0.09150149, (float)0.08824220, (float)0.08498220, (float)0.08172106,
	(float)0.07845904, (float)0.07519618, (float)0.07193252, (float)0.06866808,
	(float)0.06540315, (float)0.06213728, (float)0.05887074, (float)0.05560357,
	(float)0.05233581, (float)0.04906749, (float)0.04579888, (float)0.04252954,
	(float)0.03925974, (float)0.03598953, (float)0.03271893, (float)0.02944798,
	(float)0.02617695, (float)0.02290541, (float)0.01963361, (float)0.01636161,
	(float)0.01308943, (float)0.00981712, (float)0.00654493, (float)0.00327244,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000,
	(float)0.00000000, (float)0.00000000, (float)0.00000000, (float)0.00000000 };

/*
* http://www.kurims.kyoto-u.ac.jp/~ooura/fft.html
* Copyright Takuya OOURA, 1996-2001
*
* You may use, copy, modify and distribute this code for any purpose (include
* commercial use) and without fee. Please refer to this package when you modify
* this code.
*
* Changes:
* Trivial type modifications by the WebRTC authors.
*/

	static void makewt(size_t nw, size_t *ip, float *w);

	static void makect(size_t nc, size_t *ip, float *c);

	static void bitrv2(size_t n, size_t *ip, float *a);

	static void cftfsub(size_t n, float *a, float *w);

	static void cftbsub(size_t n, float *a, float *w);

	static void cft1st(size_t n, float *a, float *w);

	static void cftmdl(size_t n, size_t l, float *a, float *w);

	static void rftfsub(size_t n, float *a, size_t nc, float *c);

	static void rftbsub(size_t n, float *a, size_t nc, float *c);

void WebRtc_rdft(size_t n, int isgn, float *a, size_t *ip, float *w) {
	size_t nw, nc;
	float xi;

	nw = ip[0];
	if (n > (nw << 2)) {
		nw = n >> 2;
		makewt(nw, ip, w);
	}
	nc = ip[1];
	if (n > (nc << 2)) {
		nc = n >> 2;
		makect(nc, ip, w + nw);
	}
	if (isgn >= 0) {
		if (n > 4) {
			bitrv2(n, ip + 2, a);
			cftfsub(n, a, w);
			rftfsub(n, a, nc, w + nw);
		}
		else if (n == 4) {
			cftfsub(n, a, w);
		}
		xi = a[0] - a[1];
		a[0] += a[1];
		a[1] = xi;
	}
	else {
		a[1] = 0.5f * (a[0] - a[1]);
		a[0] -= a[1];
		if (n > 4) {
			rftbsub(n, a, nc, w + nw);
			bitrv2(n, ip + 2, a);
			cftbsub(n, a, w);
		}
		else if (n == 4) {
			cftfsub(n, a, w);
		}
	}
}

/* -------- initializing routines -------- */



static void makewt(size_t nw, size_t *ip, float *w) {
	size_t j, nwh;
	float delta, x, y;

	ip[0] = nw;
	ip[1] = 1;
	if (nw > 2) {
		nwh = nw >> 1;
		delta = atanf(1.0f) / nwh;
		w[0] = 1;
		w[1] = 0;
		w[nwh] = cosf(delta * nwh);
		w[nwh + 1] = w[nwh];
		if (nwh > 2) {
			for (j = 2; j < nwh; j += 2) {
				x = cosf(delta * j);
				y = sinf(delta * j);
				w[j] = x;
				w[j + 1] = y;
				w[nw - j] = y;
				w[nw - j + 1] = x;
			}
			bitrv2(nw, ip + 2, w);
		}
	}
}


static void makect(size_t nc, size_t *ip, float *c) {
	size_t j, nch;
	float delta;

	ip[1] = nc;
	if (nc > 1) {
		nch = nc >> 1;
		delta = atanf(1.0f) / nch;
		c[0] = cosf(delta * nch);
		c[nch] = 0.5f * c[0];
		for (j = 1; j < nch; j++) {
			c[j] = 0.5f * cosf(delta * j);
			c[nc - j] = 0.5f * sinf(delta * j);
		}
	}
}


/* -------- child routines -------- */


static void bitrv2(size_t n, size_t *ip, float *a) {
	size_t j, j1, k, k1, l, m, m2;
	float xr, xi, yr, yi;

	ip[0] = 0;
	l = n;
	m = 1;
	while ((m << 3) < l) {
		l >>= 1;
		for (j = 0; j < m; j++) {
			ip[m + j] = ip[j] + l;
		}
		m <<= 1;
	}
	m2 = 2 * m;
	if ((m << 3) == l) {
		for (k = 0; k < m; k++) {
			for (j = 0; j < k; j++) {
				j1 = 2 * j + ip[k];
				k1 = 2 * k + ip[j];
				xr = a[j1];
				xi = a[j1 + 1];
				yr = a[k1];
				yi = a[k1 + 1];
				a[j1] = yr;
				a[j1 + 1] = yi;
				a[k1] = xr;
				a[k1 + 1] = xi;
				j1 += m2;
				k1 += 2 * m2;
				xr = a[j1];
				xi = a[j1 + 1];
				yr = a[k1];
				yi = a[k1 + 1];
				a[j1] = yr;
				a[j1 + 1] = yi;
				a[k1] = xr;
				a[k1 + 1] = xi;
				j1 += m2;
				k1 -= m2;
				xr = a[j1];
				xi = a[j1 + 1];
				yr = a[k1];
				yi = a[k1 + 1];
				a[j1] = yr;
				a[j1 + 1] = yi;
				a[k1] = xr;
				a[k1 + 1] = xi;
				j1 += m2;
				k1 += 2 * m2;
				xr = a[j1];
				xi = a[j1 + 1];
				yr = a[k1];
				yi = a[k1 + 1];
				a[j1] = yr;
				a[j1 + 1] = yi;
				a[k1] = xr;
				a[k1 + 1] = xi;
			}
			j1 = 2 * k + m2 + ip[k];
			k1 = j1 + m2;
			xr = a[j1];
			xi = a[j1 + 1];
			yr = a[k1];
			yi = a[k1 + 1];
			a[j1] = yr;
			a[j1 + 1] = yi;
			a[k1] = xr;
			a[k1 + 1] = xi;
		}
	}
	else {
		for (k = 1; k < m; k++) {
			for (j = 0; j < k; j++) {
				j1 = 2 * j + ip[k];
				k1 = 2 * k + ip[j];
				xr = a[j1];
				xi = a[j1 + 1];
				yr = a[k1];
				yi = a[k1 + 1];
				a[j1] = yr;
				a[j1 + 1] = yi;
				a[k1] = xr;
				a[k1 + 1] = xi;
				j1 += m2;
				k1 += m2;
				xr = a[j1];
				xi = a[j1 + 1];
				yr = a[k1];
				yi = a[k1 + 1];
				a[j1] = yr;
				a[j1 + 1] = yi;
				a[k1] = xr;
				a[k1 + 1] = xi;
			}
		}
	}
}

static void cftfsub(size_t n, float *a, float *w) {
	size_t j, j1, j2, j3, l;
	float x0r, x0i, x1r, x1i, x2r, x2i, x3r, x3i;

	l = 2;
	if (n > 8) {
		cft1st(n, a, w);
		l = 8;
		while ((l << 2) < n) {
			cftmdl(n, l, a, w);
			l <<= 2;
		}
	}
	if ((l << 2) == n) {
		for (j = 0; j < l; j += 2) {
			j1 = j + l;
			j2 = j1 + l;
			j3 = j2 + l;
			x0r = a[j] + a[j1];
			x0i = a[j + 1] + a[j1 + 1];
			x1r = a[j] - a[j1];
			x1i = a[j + 1] - a[j1 + 1];
			x2r = a[j2] + a[j3];
			x2i = a[j2 + 1] + a[j3 + 1];
			x3r = a[j2] - a[j3];
			x3i = a[j2 + 1] - a[j3 + 1];
			a[j] = x0r + x2r;
			a[j + 1] = x0i + x2i;
			a[j2] = x0r - x2r;
			a[j2 + 1] = x0i - x2i;
			a[j1] = x1r - x3i;
			a[j1 + 1] = x1i + x3r;
			a[j3] = x1r + x3i;
			a[j3 + 1] = x1i - x3r;
		}
	}
	else {
		for (j = 0; j < l; j += 2) {
			j1 = j + l;
			x0r = a[j] - a[j1];
			x0i = a[j + 1] - a[j1 + 1];
			a[j] += a[j1];
			a[j + 1] += a[j1 + 1];
			a[j1] = x0r;
			a[j1 + 1] = x0i;
		}
	}
}


static void cftbsub(size_t n, float *a, float *w) {
	size_t j, j1, j2, j3, l;
	float x0r, x0i, x1r, x1i, x2r, x2i, x3r, x3i;

	l = 2;
	if (n > 8) {
		cft1st(n, a, w);
		l = 8;
		while ((l << 2) < n) {
			cftmdl(n, l, a, w);
			l <<= 2;
		}
	}
	if ((l << 2) == n) {
		for (j = 0; j < l; j += 2) {
			j1 = j + l;
			j2 = j1 + l;
			j3 = j2 + l;
			x0r = a[j] + a[j1];
			x0i = -a[j + 1] - a[j1 + 1];
			x1r = a[j] - a[j1];
			x1i = -a[j + 1] + a[j1 + 1];
			x2r = a[j2] + a[j3];
			x2i = a[j2 + 1] + a[j3 + 1];
			x3r = a[j2] - a[j3];
			x3i = a[j2 + 1] - a[j3 + 1];
			a[j] = x0r + x2r;
			a[j + 1] = x0i - x2i;
			a[j2] = x0r - x2r;
			a[j2 + 1] = x0i + x2i;
			a[j1] = x1r - x3i;
			a[j1 + 1] = x1i - x3r;
			a[j3] = x1r + x3i;
			a[j3 + 1] = x1i + x3r;
		}
	}
	else {
		for (j = 0; j < l; j += 2) {
			j1 = j + l;
			x0r = a[j] - a[j1];
			x0i = -a[j + 1] + a[j1 + 1];
			a[j] += a[j1];
			a[j + 1] = -a[j + 1] - a[j1 + 1];
			a[j1] = x0r;
			a[j1 + 1] = x0i;
		}
	}
}


static void cft1st(size_t n, float *a, float *w) {
	size_t j, k1, k2;
	float wk1r, wk1i, wk2r, wk2i, wk3r, wk3i;
	float x0r, x0i, x1r, x1i, x2r, x2i, x3r, x3i;

	x0r = a[0] + a[2];
	x0i = a[1] + a[3];
	x1r = a[0] - a[2];
	x1i = a[1] - a[3];
	x2r = a[4] + a[6];
	x2i = a[5] + a[7];
	x3r = a[4] - a[6];
	x3i = a[5] - a[7];
	a[0] = x0r + x2r;
	a[1] = x0i + x2i;
	a[4] = x0r - x2r;
	a[5] = x0i - x2i;
	a[2] = x1r - x3i;
	a[3] = x1i + x3r;
	a[6] = x1r + x3i;
	a[7] = x1i - x3r;
	wk1r = w[2];
	x0r = a[8] + a[10];
	x0i = a[9] + a[11];
	x1r = a[8] - a[10];
	x1i = a[9] - a[11];
	x2r = a[12] + a[14];
	x2i = a[13] + a[15];
	x3r = a[12] - a[14];
	x3i = a[13] - a[15];
	a[8] = x0r + x2r;
	a[9] = x0i + x2i;
	a[12] = x2i - x0i;
	a[13] = x0r - x2r;
	x0r = x1r - x3i;
	x0i = x1i + x3r;
	a[10] = wk1r * (x0r - x0i);
	a[11] = wk1r * (x0r + x0i);
	x0r = x3i + x1r;
	x0i = x3r - x1i;
	a[14] = wk1r * (x0i - x0r);
	a[15] = wk1r * (x0i + x0r);
	k1 = 0;
	for (j = 16; j < n; j += 16) {
		k1 += 2;
		k2 = 2 * k1;
		wk2r = w[k1];
		wk2i = w[k1 + 1];
		wk1r = w[k2];
		wk1i = w[k2 + 1];
		wk3r = wk1r - 2 * wk2i * wk1i;
		wk3i = 2 * wk2i * wk1r - wk1i;
		x0r = a[j] + a[j + 2];
		x0i = a[j + 1] + a[j + 3];
		x1r = a[j] - a[j + 2];
		x1i = a[j + 1] - a[j + 3];
		x2r = a[j + 4] + a[j + 6];
		x2i = a[j + 5] + a[j + 7];
		x3r = a[j + 4] - a[j + 6];
		x3i = a[j + 5] - a[j + 7];
		a[j] = x0r + x2r;
		a[j + 1] = x0i + x2i;
		x0r -= x2r;
		x0i -= x2i;
		a[j + 4] = wk2r * x0r - wk2i * x0i;
		a[j + 5] = wk2r * x0i + wk2i * x0r;
		x0r = x1r - x3i;
		x0i = x1i + x3r;
		a[j + 2] = wk1r * x0r - wk1i * x0i;
		a[j + 3] = wk1r * x0i + wk1i * x0r;
		x0r = x1r + x3i;
		x0i = x1i - x3r;
		a[j + 6] = wk3r * x0r - wk3i * x0i;
		a[j + 7] = wk3r * x0i + wk3i * x0r;
		wk1r = w[k2 + 2];
		wk1i = w[k2 + 3];
		wk3r = wk1r - 2 * wk2r * wk1i;
		wk3i = 2 * wk2r * wk1r - wk1i;
		x0r = a[j + 8] + a[j + 10];
		x0i = a[j + 9] + a[j + 11];
		x1r = a[j + 8] - a[j + 10];
		x1i = a[j + 9] - a[j + 11];
		x2r = a[j + 12] + a[j + 14];
		x2i = a[j + 13] + a[j + 15];
		x3r = a[j + 12] - a[j + 14];
		x3i = a[j + 13] - a[j + 15];
		a[j + 8] = x0r + x2r;
		a[j + 9] = x0i + x2i;
		x0r -= x2r;
		x0i -= x2i;
		a[j + 12] = -wk2i * x0r - wk2r * x0i;
		a[j + 13] = -wk2i * x0i + wk2r * x0r;
		x0r = x1r - x3i;
		x0i = x1i + x3r;
		a[j + 10] = wk1r * x0r - wk1i * x0i;
		a[j + 11] = wk1r * x0i + wk1i * x0r;
		x0r = x1r + x3i;
		x0i = x1i - x3r;
		a[j + 14] = wk3r * x0r - wk3i * x0i;
		a[j + 15] = wk3r * x0i + wk3i * x0r;
	}
}


static void cftmdl(size_t n, size_t l, float *a, float *w) {
	size_t j, j1, j2, j3, k, k1, k2, m, m2;
	float wk1r, wk1i, wk2r, wk2i, wk3r, wk3i;
	float x0r, x0i, x1r, x1i, x2r, x2i, x3r, x3i;

	m = l << 2;
	for (j = 0; j < l; j += 2) {
		j1 = j + l;
		j2 = j1 + l;
		j3 = j2 + l;
		x0r = a[j] + a[j1];
		x0i = a[j + 1] + a[j1 + 1];
		x1r = a[j] - a[j1];
		x1i = a[j + 1] - a[j1 + 1];
		x2r = a[j2] + a[j3];
		x2i = a[j2 + 1] + a[j3 + 1];
		x3r = a[j2] - a[j3];
		x3i = a[j2 + 1] - a[j3 + 1];
		a[j] = x0r + x2r;
		a[j + 1] = x0i + x2i;
		a[j2] = x0r - x2r;
		a[j2 + 1] = x0i - x2i;
		a[j1] = x1r - x3i;
		a[j1 + 1] = x1i + x3r;
		a[j3] = x1r + x3i;
		a[j3 + 1] = x1i - x3r;
	}
	wk1r = w[2];
	for (j = m; j < l + m; j += 2) {
		j1 = j + l;
		j2 = j1 + l;
		j3 = j2 + l;
		x0r = a[j] + a[j1];
		x0i = a[j + 1] + a[j1 + 1];
		x1r = a[j] - a[j1];
		x1i = a[j + 1] - a[j1 + 1];
		x2r = a[j2] + a[j3];
		x2i = a[j2 + 1] + a[j3 + 1];
		x3r = a[j2] - a[j3];
		x3i = a[j2 + 1] - a[j3 + 1];
		a[j] = x0r + x2r;
		a[j + 1] = x0i + x2i;
		a[j2] = x2i - x0i;
		a[j2 + 1] = x0r - x2r;
		x0r = x1r - x3i;
		x0i = x1i + x3r;
		a[j1] = wk1r * (x0r - x0i);
		a[j1 + 1] = wk1r * (x0r + x0i);
		x0r = x3i + x1r;
		x0i = x3r - x1i;
		a[j3] = wk1r * (x0i - x0r);
		a[j3 + 1] = wk1r * (x0i + x0r);
	}
	k1 = 0;
	m2 = 2 * m;
	for (k = m2; k < n; k += m2) {
		k1 += 2;
		k2 = 2 * k1;
		wk2r = w[k1];
		wk2i = w[k1 + 1];
		wk1r = w[k2];
		wk1i = w[k2 + 1];
		wk3r = wk1r - 2 * wk2i * wk1i;
		wk3i = 2 * wk2i * wk1r - wk1i;
		for (j = k; j < l + k; j += 2) {
			j1 = j + l;
			j2 = j1 + l;
			j3 = j2 + l;
			x0r = a[j] + a[j1];
			x0i = a[j + 1] + a[j1 + 1];
			x1r = a[j] - a[j1];
			x1i = a[j + 1] - a[j1 + 1];
			x2r = a[j2] + a[j3];
			x2i = a[j2 + 1] + a[j3 + 1];
			x3r = a[j2] - a[j3];
			x3i = a[j2 + 1] - a[j3 + 1];
			a[j] = x0r + x2r;
			a[j + 1] = x0i + x2i;
			x0r -= x2r;
			x0i -= x2i;
			a[j2] = wk2r * x0r - wk2i * x0i;
			a[j2 + 1] = wk2r * x0i + wk2i * x0r;
			x0r = x1r - x3i;
			x0i = x1i + x3r;
			a[j1] = wk1r * x0r - wk1i * x0i;
			a[j1 + 1] = wk1r * x0i + wk1i * x0r;
			x0r = x1r + x3i;
			x0i = x1i - x3r;
			a[j3] = wk3r * x0r - wk3i * x0i;
			a[j3 + 1] = wk3r * x0i + wk3i * x0r;
		}
		wk1r = w[k2 + 2];
		wk1i = w[k2 + 3];
		wk3r = wk1r - 2 * wk2r * wk1i;
		wk3i = 2 * wk2r * wk1r - wk1i;
		for (j = k + m; j < l + (k + m); j += 2) {
			j1 = j + l;
			j2 = j1 + l;
			j3 = j2 + l;
			x0r = a[j] + a[j1];
			x0i = a[j + 1] + a[j1 + 1];
			x1r = a[j] - a[j1];
			x1i = a[j + 1] - a[j1 + 1];
			x2r = a[j2] + a[j3];
			x2i = a[j2 + 1] + a[j3 + 1];
			x3r = a[j2] - a[j3];
			x3i = a[j2 + 1] - a[j3 + 1];
			a[j] = x0r + x2r;
			a[j + 1] = x0i + x2i;
			x0r -= x2r;
			x0i -= x2i;
			a[j2] = -wk2i * x0r - wk2r * x0i;
			a[j2 + 1] = -wk2i * x0i + wk2r * x0r;
			x0r = x1r - x3i;
			x0i = x1i + x3r;
			a[j1] = wk1r * x0r - wk1i * x0i;
			a[j1 + 1] = wk1r * x0i + wk1i * x0r;
			x0r = x1r + x3i;
			x0i = x1i - x3r;
			a[j3] = wk3r * x0r - wk3i * x0i;
			a[j3 + 1] = wk3r * x0i + wk3i * x0r;
		}
	}
}


static void rftfsub(size_t n, float *a, size_t nc, float *c) {
	size_t j, k, kk, ks, m;
	float wkr, wki, xr, xi, yr, yi;

	m = n >> 1;
	ks = 2 * nc / m;
	kk = 0;
	for (j = 2; j < m; j += 2) {
		k = n - j;
		kk += ks;
		wkr = 0.5f - c[nc - kk];
		wki = c[kk];
		xr = a[j] - a[k];
		xi = a[j + 1] + a[k + 1];
		yr = wkr * xr - wki * xi;
		yi = wkr * xi + wki * xr;
		a[j] -= yr;
		a[j + 1] -= yi;
		a[k] += yr;
		a[k + 1] -= yi;
	}
}


static void rftbsub(size_t n, float *a, size_t nc, float *c) {
	size_t j, k, kk, ks, m;
	float wkr, wki, xr, xi, yr, yi;

	a[1] = -a[1];
	m = n >> 1;
	ks = 2 * nc / m;
	kk = 0;
	for (j = 2; j < m; j += 2) {
		k = n - j;
		kk += ks;
		wkr = 0.5f - c[nc - kk];
		wki = c[kk];
		xr = a[j] - a[k];
		xi = a[j + 1] + a[k + 1];
		yr = wkr * xr + wki * xi;
		yi = wkr * xi - wki * xr;
		a[j] -= yr;
		a[j + 1] = yi - a[j + 1];
		a[k] += yr;
		a[k + 1] = yi - a[k + 1];
	}
	a[m + 1] = -a[m + 1];
}
//Set Feature Extraction Parameters
//WebRTCLRT/
//
static void set_feature_extraction_parameters(NoiseSuppressionC *self) {
	// Bin size of histogram.
	self->featureExtractionParams.binSizeLrt = 0.1f;
	self->featureExtractionParams.binSizeSpecFlat = 0.05f;
	self->featureExtractionParams.binSizeSpecDiff = 0.1f;

	// Range of histogram over which LRT threshold is computed.
	self->featureExtractionParams.rangeAvgHistLrt = 1.f;

	// Scale parameters: multiply dominant peaks of the histograms by scale factor
	// to obtain thresholds for prior model.
	// For LRT and spectral difference.
	self->featureExtractionParams.factor1ModelPars = 1.2f;
	// For spectral_flatness: used when noise is flatter than speech.
	self->featureExtractionParams.factor2ModelPars = 0.9f;

	// Peak limit for spectral flatness (varies between 0 and 1).
	self->featureExtractionParams.thresPosSpecFlat = 0.6f;

	// Limit on spacing of two highest peaks in histogram: spacing determined by
	// bin size.
	self->featureExtractionParams.limitPeakSpacingSpecFlat =
		2 * self->featureExtractionParams.binSizeSpecFlat;
	self->featureExtractionParams.limitPeakSpacingSpecDiff =
		2 * self->featureExtractionParams.binSizeSpecDiff;

	// Limit on relevance of second peak.
	self->featureExtractionParams.limitPeakWeightsSpecFlat = 0.5f;
	self->featureExtractionParams.limitPeakWeightsSpecDiff = 0.5f;

	// Fluctuation limit of LRT feature.
	self->featureExtractionParams.thresFluctLrt = 0.05f;

	// Limit on the max and min values for the feature thresholds.
	self->featureExtractionParams.maxLrt = 1.f;
	self->featureExtractionParams.minLrt = 0.2f;

	self->featureExtractionParams.maxSpecFlat = 0.95f;
	self->featureExtractionParams.minSpecFlat = 0.1f;

	self->featureExtractionParams.maxSpecDiff = 1.f;
	self->featureExtractionParams.minSpecDiff = 0.16f;

	// Criteria of weight of histogram peak to accept/reject feature.
	self->featureExtractionParams.thresWeightSpecFlat =
		(int)(0.3 * (self->modelUpdatePars[1]));  // For spectral flatness.
	self->featureExtractionParams.thresWeightSpecDiff =
		(int)(0.3 * (self->modelUpdatePars[1]));  // For spectral difference.
}

//
int WebRtcNs_InitCore(NoiseSuppressionC *self, uint32_t fs) {
	int i;
	// Check for valid pointer.
	if (self == NULL) {
		return -1;
	}

	// Initialization of struct.
	if (fs == 8000 || fs == 16000 || fs == 32000 || fs == 48000 || fs == 44100) {
		self->fs = fs;
	}
	else {
		return -1;
	}
	self->windShift = 0;
	// We only support 10ms frames.
	if (fs == 8000) {
		self->blockLen = 80;
		self->anaLen = 128;
		self->window = kBlocks80w128;
	}
	else {
		self->blockLen = 160;
		self->anaLen = 256;
		self->window = kBlocks160w256;
	}
	self->magnLen = self->anaLen / 2 + 1;  // Number of frequency bins.

										   // Initialize FFT work arrays.
	self->ip[0] = 0;  // Setting this triggers initialization.
	memset(self->dataBuf, 0, sizeof(float) * ANAL_BLOCKL_MAX);
	WebRtc_rdft(self->anaLen, 1, self->dataBuf, self->ip, self->wfft);

	memset(self->analyzeBuf, 0, sizeof(float) * ANAL_BLOCKL_MAX);
	memset(self->dataBuf, 0, sizeof(float) * ANAL_BLOCKL_MAX);
	memset(self->syntBuf, 0, sizeof(float) * ANAL_BLOCKL_MAX);

	// For HB processing.
	memset(self->dataBufHB,
		0,
		sizeof(float) * NUM_HIGH_BANDS_MAX * ANAL_BLOCKL_MAX);

	// For quantile noise estimation.
	memset(self->quantile, 0, sizeof(float) * HALF_ANAL_BLOCKL);
	for (i = 0; i < SIMULT * HALF_ANAL_BLOCKL; i++) {
		self->lquantile[i] = 8.f;
		self->density[i] = 0.3f;
	}

	for (i = 0; i < SIMULT; i++) {
		self->counter[i] =
			(int)floorf((float)(END_STARTUP_LONG * (i + 1)) / (float)SIMULT);
	}

	self->updates = 0;

	// Wiener filter initialization.
	for (i = 0; i < HALF_ANAL_BLOCKL; i++) {
		self->smooth[i] = 1.f;
	}

	// Set the aggressiveness: default.
	self->aggrMode = 0;

	// Initialize variables for new method.
	self->priorSpeechProb = 0.5f;  // Prior prob for speech/noise.
								   // Previous analyze mag spectrum.
	memset(self->magnPrevAnalyze, 0, sizeof(float) * HALF_ANAL_BLOCKL);
	// Previous process mag spectrum.
	memset(self->magnPrevProcess, 0, sizeof(float) * HALF_ANAL_BLOCKL);
	// Current noise-spectrum.
	memset(self->noise, 0, sizeof(float) * HALF_ANAL_BLOCKL);
	// Previous noise-spectrum.
	memset(self->noisePrev, 0, sizeof(float) * HALF_ANAL_BLOCKL);
	// Conservative noise spectrum estimate.
	memset(self->magnAvgPause, 0, sizeof(float) * HALF_ANAL_BLOCKL);
	// For estimation of HB in second pass.
	memset(self->speechProb, 0, sizeof(float) * HALF_ANAL_BLOCKL);
	// Initial average magnitude spectrum.
	memset(self->initMagnEst, 0, sizeof(float) * HALF_ANAL_BLOCKL);
	for (i = 0; i < HALF_ANAL_BLOCKL; i++) {
		// Smooth LR (same as threshold).
		self->logLrtTimeAvg[i] = LRT_FEATURE_THR;
	}

	// Feature quantities.
	// Spectral flatness (start on threshold).
	self->featureData[0] = SF_FEATURE_THR;
	self->featureData[1] = 0.f;  // Spectral entropy: not used in this version.
	self->featureData[2] = 0.f;  // Spectral variance: not used in this version.
								 // Average LRT factor (start on threshold).
	self->featureData[3] = LRT_FEATURE_THR;
	// Spectral template diff (start on threshold).
	self->featureData[4] = SF_FEATURE_THR;
	self->featureData[5] = 0.f;  // Normalization for spectral difference.
								 // Window time-average of input magnitude spectrum.
	self->featureData[6] = 0.f;

	// Histogram quantities: used to estimate/update thresholds for features.
	memset(self->histLrt, 0, sizeof(int) * HIST_PAR_EST);
	memset(self->histSpecFlat, 0, sizeof(int) * HIST_PAR_EST);
	memset(self->histSpecDiff, 0, sizeof(int) * HIST_PAR_EST);


	self->blockInd = -1;  // Frame counter.
						  // Default threshold for LRT feature.
	self->priorModelPars[0] = LRT_FEATURE_THR;
	// Threshold for spectral flatness: determined on-line.
	self->priorModelPars[1] = 0.5f;
	// sgn_map par for spectral measure: 1 for flatness measure.
	self->priorModelPars[2] = 1.f;
	// Threshold for template-difference feature: determined on-line.
	self->priorModelPars[3] = 0.5f;
	// Default weighting parameter for LRT feature.
	self->priorModelPars[4] = 1.f;
	// Default weighting parameter for spectral flatness feature.
	self->priorModelPars[5] = 0.f;
	// Default weighting parameter for spectral difference feature.
	self->priorModelPars[6] = 0.f;

	// Update flag for parameters:
	// 0 no update, 1 = update once, 2 = update every window.
	self->modelUpdatePars[0] = 2;
	self->modelUpdatePars[1] = 500;  // Window for update.
									 // Counter for update of conservative noise spectrum.
	self->modelUpdatePars[2] = 0;
	// Counter if the feature thresholds are updated during the sequence.
	self->modelUpdatePars[3] = self->modelUpdatePars[1];

	self->signalEnergy = 0.0;
	self->sumMagn = 0.0;
	self->whiteNoiseLevel = 0.0;
	self->pinkNoiseNumerator = 0.0;
	self->pinkNoiseExp = 0.0;

	set_feature_extraction_parameters(self);

	// Default mode.
	WebRtcNs_set_policy_core(self, 0);

	self->initFlag = 1;
	return 0;
}

//
static void NoiseEstimation(NoiseSuppressionC *self,
	float *magn,
	float *noise) {
	size_t i, s, offset = 0;
	float lmagn[HALF_ANAL_BLOCKL], delta;

	if (self->updates < END_STARTUP_LONG) {
		self->updates++;
	}

	for (i = 0; i < self->magnLen; i++) {
		lmagn[i] = logf(magn[i]);
	}

	// Loop over simultaneous estimates.
	for (s = 0; s < SIMULT; s++) {
		offset = s * self->magnLen;

		// newquantest(...)
		for (i = 0; i < self->magnLen; i++) {
			// Compute delta.
			if (self->density[offset + i] > 1.0) {
				delta = FACTOR * 1.f / self->density[offset + i];
			}
			else {
				delta = FACTOR;
			}

			// Update log quantile estimate.
			if (lmagn[i] > self->lquantile[offset + i]) {
				self->lquantile[offset + i] +=
					QUANTILE * delta / (float)(self->counter[s] + 1);
			}
			else {
				self->lquantile[offset + i] -=
					(1.f - QUANTILE) * delta / (float)(self->counter[s] + 1);
			}

			// Update density estimate.
			if (fabsf(lmagn[i] - self->lquantile[offset + i]) < WIDTH) {
				self->density[offset + i] =
					((float)self->counter[s] * self->density[offset + i] +
						1.f / (2.f * WIDTH)) /
						(float)(self->counter[s] + 1);
			}
		}  // End loop over magnitude spectrum.

		if (self->counter[s] >= END_STARTUP_LONG) {
			self->counter[s] = 0;
			if (self->updates >= END_STARTUP_LONG) {
				for (i = 0; i < self->magnLen; i++) {
					self->quantile[i] = expf(self->lquantile[offset + i]);
				}
			}
		}

		self->counter[s]++;
	}  // End loop over simultaneous estimates.

	   // Sequentially update the noise during startup.
	if (self->updates < END_STARTUP_LONG) {
		// Use the last "s" to get noise during startup that differ from zero.
		for (i = 0; i < self->magnLen; i++) {
			self->quantile[i] = expf(self->lquantile[offset + i]);
		}
	}

	for (i = 0; i < self->magnLen; i++) {
		noise[i] = self->quantile[i];
	}
}

// Extract thresholds for feature parameters.
// Histograms are computed over some window size (given by
// self->modelUpdatePars[1]).
// Thresholds and weights are extracted every window.
// |flag| = 0 updates histogram only, |flag| = 1 computes the threshold/weights.
// Threshold and weights are returned in: self->priorModelPars.
static void FeatureParameterExtraction(NoiseSuppressionC *self, int flag) {
	int i, useFeatureSpecFlat, useFeatureSpecDiff, numHistLrt;
	int maxPeak1, maxPeak2;
	int weightPeak1SpecFlat, weightPeak2SpecFlat, weightPeak1SpecDiff,
		weightPeak2SpecDiff;

	float binMid, featureSum;
	float posPeak1SpecFlat, posPeak2SpecFlat, posPeak1SpecDiff, posPeak2SpecDiff;
	float fluctLrt, avgHistLrt, avgSquareHistLrt, avgHistLrtCompl;

	// 3 features: LRT, flatness, difference.
	// lrt_feature = self->featureData[3];
	// flat_feature = self->featureData[0];
	// diff_feature = self->featureData[4];

	// Update histograms.
	if (flag == 0) {
		// LRT
		if ((self->featureData[3] <
			HIST_PAR_EST * self->featureExtractionParams.binSizeLrt) &&
			(self->featureData[3] >= 0.0)) {
			i = (int)(self->featureData[3] /
				self->featureExtractionParams.binSizeLrt);
			self->histLrt[i]++;
		}
		// Spectral flatness.
		if ((self->featureData[0] <
			HIST_PAR_EST * self->featureExtractionParams.binSizeSpecFlat) &&
			(self->featureData[0] >= 0.0)) {
			i = (int)(self->featureData[0] /
				self->featureExtractionParams.binSizeSpecFlat);
			self->histSpecFlat[i]++;
		}
		// Spectral difference.
		if ((self->featureData[4] <
			HIST_PAR_EST * self->featureExtractionParams.binSizeSpecDiff) &&
			(self->featureData[4] >= 0.0)) {
			i = (int)(self->featureData[4] /
				self->featureExtractionParams.binSizeSpecDiff);
			self->histSpecDiff[i]++;
		}
	}

	// Extract parameters for speech/noise probability.
	if (flag == 1) {
		// LRT feature: compute the average over
		// self->featureExtractionParams.rangeAvgHistLrt.
		avgHistLrt = 0.0;
		avgHistLrtCompl = 0.0;
		avgSquareHistLrt = 0.0;
		numHistLrt = 0;
		for (i = 0; i < HIST_PAR_EST; i++) {
			binMid = ((float)i + 0.5f) * self->featureExtractionParams.binSizeLrt;
			if (binMid <= self->featureExtractionParams.rangeAvgHistLrt) {
				avgHistLrt += self->histLrt[i] * binMid;
				numHistLrt += self->histLrt[i];
			}
			avgSquareHistLrt += self->histLrt[i] * binMid * binMid;
			avgHistLrtCompl += self->histLrt[i] * binMid;
		}
		if (numHistLrt > 0) {
			avgHistLrt = avgHistLrt / ((float)numHistLrt);
		}
		avgHistLrtCompl = avgHistLrtCompl / ((float)self->modelUpdatePars[1]);
		avgSquareHistLrt = avgSquareHistLrt / ((float)self->modelUpdatePars[1]);
		fluctLrt = avgSquareHistLrt - avgHistLrt * avgHistLrtCompl;
		// Get threshold for LRT feature.
		if (fluctLrt < self->featureExtractionParams.thresFluctLrt) {
			// Very low fluctuation, so likely noise.
			self->priorModelPars[0] = self->featureExtractionParams.maxLrt;
		}
		else {
			self->priorModelPars[0] =
				self->featureExtractionParams.factor1ModelPars * avgHistLrt;
			// Check if value is within min/max range.
			if (self->priorModelPars[0] < self->featureExtractionParams.minLrt) {
				self->priorModelPars[0] = self->featureExtractionParams.minLrt;
			}
			if (self->priorModelPars[0] > self->featureExtractionParams.maxLrt) {
				self->priorModelPars[0] = self->featureExtractionParams.maxLrt;
			}
		}
		// Done with LRT feature.

		// For spectral flatness and spectral difference: compute the main peaks of
		// histogram.
		maxPeak1 = 0;
		maxPeak2 = 0;
		posPeak1SpecFlat = 0.0;
		posPeak2SpecFlat = 0.0;
		weightPeak1SpecFlat = 0;
		weightPeak2SpecFlat = 0;

		// Peaks for flatness.
		for (i = 0; i < HIST_PAR_EST; i++) {
			binMid =
				(i + 0.5f) * self->featureExtractionParams.binSizeSpecFlat;
			if (self->histSpecFlat[i] > maxPeak1) {
				// Found new "first" peak.
				maxPeak2 = maxPeak1;
				weightPeak2SpecFlat = weightPeak1SpecFlat;
				posPeak2SpecFlat = posPeak1SpecFlat;

				maxPeak1 = self->histSpecFlat[i];
				weightPeak1SpecFlat = self->histSpecFlat[i];
				posPeak1SpecFlat = binMid;
			}
			else if (self->histSpecFlat[i] > maxPeak2) {
				// Found new "second" peak.
				maxPeak2 = self->histSpecFlat[i];
				weightPeak2SpecFlat = self->histSpecFlat[i];
				posPeak2SpecFlat = binMid;
			}
		}

		// Compute two peaks for spectral difference.
		maxPeak1 = 0;
		maxPeak2 = 0;
		posPeak1SpecDiff = 0.0;
		posPeak2SpecDiff = 0.0;
		weightPeak1SpecDiff = 0;
		weightPeak2SpecDiff = 0;
		// Peaks for spectral difference.
		for (i = 0; i < HIST_PAR_EST; i++) {
			binMid =
				((float)i + 0.5f) * self->featureExtractionParams.binSizeSpecDiff;
			if (self->histSpecDiff[i] > maxPeak1) {
				// Found new "first" peak.
				maxPeak2 = maxPeak1;
				weightPeak2SpecDiff = weightPeak1SpecDiff;
				posPeak2SpecDiff = posPeak1SpecDiff;

				maxPeak1 = self->histSpecDiff[i];
				weightPeak1SpecDiff = self->histSpecDiff[i];
				posPeak1SpecDiff = binMid;
			}
			else if (self->histSpecDiff[i] > maxPeak2) {
				// Found new "second" peak.
				maxPeak2 = self->histSpecDiff[i];
				weightPeak2SpecDiff = self->histSpecDiff[i];
				posPeak2SpecDiff = binMid;
			}
		}

		// For spectrum flatness feature.
		useFeatureSpecFlat = 1;
		// Merge the two peaks if they are close.
		if ((fabsf(posPeak2SpecFlat - posPeak1SpecFlat) <
			self->featureExtractionParams.limitPeakSpacingSpecFlat) &&
			(weightPeak2SpecFlat >
				self->featureExtractionParams.limitPeakWeightsSpecFlat *
				weightPeak1SpecFlat)) {
			weightPeak1SpecFlat += weightPeak2SpecFlat;
			posPeak1SpecFlat = 0.5f * (posPeak1SpecFlat + posPeak2SpecFlat);
		}
		// Reject if weight of peaks is not large enough, or peak value too small.
		if (weightPeak1SpecFlat <
			self->featureExtractionParams.thresWeightSpecFlat ||
			posPeak1SpecFlat < self->featureExtractionParams.thresPosSpecFlat) {
			useFeatureSpecFlat = 0;
		}
		// If selected, get the threshold.
		if (useFeatureSpecFlat == 1) {
			// Compute the threshold.
			self->priorModelPars[1] =
				self->featureExtractionParams.factor2ModelPars * posPeak1SpecFlat;
			// Check if value is within min/max range.
			if (self->priorModelPars[1] < self->featureExtractionParams.minSpecFlat) {
				self->priorModelPars[1] = self->featureExtractionParams.minSpecFlat;
			}
			if (self->priorModelPars[1] > self->featureExtractionParams.maxSpecFlat) {
				self->priorModelPars[1] = self->featureExtractionParams.maxSpecFlat;
			}
		}
		// Done with flatness feature.

		// For template feature.
		useFeatureSpecDiff = 1;
		// Merge the two peaks if they are close.
		if ((fabsf(posPeak2SpecDiff - posPeak1SpecDiff) <
			self->featureExtractionParams.limitPeakSpacingSpecDiff) &&
			(weightPeak2SpecDiff >
				self->featureExtractionParams.limitPeakWeightsSpecDiff *
				weightPeak1SpecDiff)) {
			weightPeak1SpecDiff += weightPeak2SpecDiff;
			posPeak1SpecDiff = 0.5f * (posPeak1SpecDiff + posPeak2SpecDiff);
		}
		// Get the threshold value.
		self->priorModelPars[3] =
			self->featureExtractionParams.factor1ModelPars * posPeak1SpecDiff;
		// Reject if weight of peaks is not large enough.
		if (weightPeak1SpecDiff <
			self->featureExtractionParams.thresWeightSpecDiff) {
			useFeatureSpecDiff = 0;
		}
		// Check if value is within min/max range.
		if (self->priorModelPars[3] < self->featureExtractionParams.minSpecDiff) {
			self->priorModelPars[3] = self->featureExtractionParams.minSpecDiff;
		}
		if (self->priorModelPars[3] > self->featureExtractionParams.maxSpecDiff) {
			self->priorModelPars[3] = self->featureExtractionParams.maxSpecDiff;
		}
		// Done with spectral difference feature.

		// Don't use template feature if fluctuation of LRT feature is very low:
		// most likely just noise state.
		if (fluctLrt < self->featureExtractionParams.thresFluctLrt) {
			useFeatureSpecDiff = 0;
		}

		// Select the weights between the features.
		// self->priorModelPars[4] is weight for LRT: always selected.
		// self->priorModelPars[5] is weight for spectral flatness.
		// self->priorModelPars[6] is weight for spectral difference.
		featureSum = (float)(1 + useFeatureSpecFlat + useFeatureSpecDiff);
		self->priorModelPars[4] = 1.f / featureSum;
		self->priorModelPars[5] = ((float)useFeatureSpecFlat) / featureSum;
		self->priorModelPars[6] = ((float)useFeatureSpecDiff) / featureSum;

		// Set hists to zero for next update.
		if (self->modelUpdatePars[0] >= 1) {
			for (i = 0; i < HIST_PAR_EST; i++) {
				self->histLrt[i] = 0;
				self->histSpecFlat[i] = 0;
				self->histSpecDiff[i] = 0;
			}
		}
	}  // End of flag == 1.
}


// Compute spectral flatness on input spectrum.
// |magnIn| is the magnitude spectrum.
// Spectral flatness is returned in self->featureData[0].
//
//
static void ComputeSpectralFlatness(NoiseSuppressionC *self,
	const float *magnIn) {
	size_t i;
	size_t shiftLP = 1;  // Option to remove first bin(s) from spectral measures.
	float avgSpectralFlatnessNum, avgSpectralFlatnessDen, spectralTmp;

	// Compute spectral measures.
	// For flatness.
	avgSpectralFlatnessNum = 0.0;
	avgSpectralFlatnessDen = self->sumMagn;
	for (i = 0; i < shiftLP; i++) {
		avgSpectralFlatnessDen -= magnIn[i];
	}
	// Compute log of ratio of the geometric to arithmetic mean: check for log(0)
	// case.
	for (i = shiftLP; i < self->magnLen; i++) {
		if (magnIn[i] > 0.0) {
			avgSpectralFlatnessNum += logf(magnIn[i]);
		}
		else {
			self->featureData[0] -= SPECT_FL_TAVG * self->featureData[0];
			return;
		}
	}
	// Normalize.
	avgSpectralFlatnessDen = avgSpectralFlatnessDen / self->magnLen;
	avgSpectralFlatnessNum = avgSpectralFlatnessNum / self->magnLen;

	// Ratio and inverse log: check for case of log(0).
	spectralTmp = expf(avgSpectralFlatnessNum) / avgSpectralFlatnessDen;

	// Time-avg update of spectral flatness feature.
	self->featureData[0] += SPECT_FL_TAVG * (spectralTmp - self->featureData[0]);
	// Done with flatness feature.
}


// Compute prior and post SNR based on quantile noise estimation.
// Compute DD estimate of prior SNR.
// Inputs:
//   * |magn| is the signal magnitude spectrum estimate.
//   * |noise| is the magnitude noise spectrum estimate.
// Outputs:
//   * |snrLocPrior| is the computed prior SNR.
//   * |snrLocPost| is the computed post SNR.
//
static void ComputeSnr(const NoiseSuppressionC *self,
	const float *magn,
	const float *noise,
	float *snrLocPrior,
	float *snrLocPost) {
	size_t i;

	for (i = 0; i < self->magnLen; i++) {
		// Previous post SNR.
		// Previous estimate: based on previous frame with gain filter.
		float previousEstimateStsa = self->magnPrevAnalyze[i] /
			(self->noisePrev[i] + 0.0001f) * self->smooth[i];
		// Post SNR.
		snrLocPost[i] = 0.f;
		if (magn[i] > noise[i]) {
			snrLocPost[i] = magn[i] / (noise[i] + 0.0001f) - 1.f;
		}
		// DD estimate is sum of two terms: current estimate and previous estimate.
		// Directed decision update of snrPrior.
		snrLocPrior[i] =
			DD_PR_SNR * previousEstimateStsa + (1.f - DD_PR_SNR) * snrLocPost[i];
	}  // End of loop over frequencies.
}

// Compute the difference measure between input spectrum and a template/learned
// noise spectrum.
// |magnIn| is the input spectrum.
// The reference/template spectrum is self->magnAvgPause[i].
// Returns (normalized) spectral difference in self->featureData[4].
//
static void ComputeSpectralDifference(NoiseSuppressionC *self,
	const float *magnIn) {
	// avgDiffNormMagn = var(magnIn) - cov(magnIn, magnAvgPause)^2 /
	// var(magnAvgPause)
	size_t i;
	float avgPause, avgMagn, covMagnPause, varPause, varMagn, avgDiffNormMagn;

	avgPause = 0.0;
	avgMagn = self->sumMagn;
	// Compute average quantities.
	for (i = 0; i < self->magnLen; i++) {
		// Conservative smooth noise spectrum from pause frames.
		avgPause += self->magnAvgPause[i];
	}
	avgPause /= self->magnLen;
	avgMagn /= self->magnLen;

	covMagnPause = 0.0;
	varPause = 0.0;
	varMagn = 0.0;
	// Compute variance and covariance quantities.
	for (i = 0; i < self->magnLen; i++) {
		covMagnPause += (magnIn[i] - avgMagn) * (self->magnAvgPause[i] - avgPause);
		varPause +=
			(self->magnAvgPause[i] - avgPause) * (self->magnAvgPause[i] - avgPause);
		varMagn += (magnIn[i] - avgMagn) * (magnIn[i] - avgMagn);
	}
	covMagnPause /= self->magnLen;
	varPause /= self->magnLen;
	varMagn /= self->magnLen;
	// Update of average magnitude spectrum.
	self->featureData[6] += self->signalEnergy;

	avgDiffNormMagn =
		varMagn - (covMagnPause * covMagnPause) / (varPause + 0.0001f);
	// Normalize and compute time-avg update of difference feature.
	avgDiffNormMagn = avgDiffNormMagn / (self->featureData[5] + 0.0001f);
	self->featureData[4] +=
		SPECT_DIFF_TAVG * (avgDiffNormMagn - self->featureData[4]);
}


// Compute speech/noise 
//probability.speech/noiseprobSpeechFinal
// Speech/noise probability is returned in |probSpeechFinal|.
// |magn| is the input magnitude spectrum.
// |noise| is the noise spectrum.
//ComputeSnr
// |snrLocPrior| is the prior SNR for each frequency.
// |snrLocPost| is the post SNR for each frequency.
static void SpeechNoiseProb(NoiseSuppressionC *self,
	float *probSpeechFinal,
	const float *snrLocPrior,
	const float *snrLocPost) {
	size_t i;
	int sgnMap;
	float invLrt, gainPrior, indPrior;
	float logLrtTimeAvgKsum, besselTmp;
	float indicator0, indicator1, indicator2;
	float tmpFloat1, tmpFloat2;
	float weightIndPrior0, weightIndPrior1, weightIndPrior2;
	float threshPrior0, threshPrior1, threshPrior2;
	float widthPrior, widthPrior0, widthPrior1, widthPrior2;

	widthPrior0 = WIDTH_PR_MAP;
	// Width for pause region: lower range, so increase width in tanh map.
	widthPrior1 = 2.f * WIDTH_PR_MAP;
	widthPrior2 = 2.f * WIDTH_PR_MAP;  // For spectral-difference measure.

									   // Threshold parameters for features.
	threshPrior0 = self->priorModelPars[0];
	threshPrior1 = self->priorModelPars[1];
	threshPrior2 = self->priorModelPars[3];

	// Sign for flatness feature.
	sgnMap = (int)(self->priorModelPars[2]);

	// Weight parameters for features.
	weightIndPrior0 = self->priorModelPars[4];
	weightIndPrior1 = self->priorModelPars[5];
	weightIndPrior2 = self->priorModelPars[6];

	// Compute feature based on average LR factor.
	// This is the average over all frequencies of the smooth log LRT.
	logLrtTimeAvgKsum = 0.0;
	for (i = 0; i < self->magnLen; i++) {
		tmpFloat1 = 1.f + 2.f * snrLocPrior[i];
		tmpFloat2 = 2.f * snrLocPrior[i] / (tmpFloat1 + 0.0001f);
		besselTmp = (snrLocPost[i] + 1.f) * tmpFloat2;
		self->logLrtTimeAvg[i] +=
			LRT_TAVG * (besselTmp - logf(tmpFloat1) - self->logLrtTimeAvg[i]);
		logLrtTimeAvgKsum += self->logLrtTimeAvg[i];
	}
	logLrtTimeAvgKsum = logLrtTimeAvgKsum / (self->magnLen);
	self->featureData[3] = logLrtTimeAvgKsum;
	// Done with computation of LR factor.

	// Compute the indicator functions.
	// Average LRT feature.
	widthPrior = widthPrior0;
	// Use larger width in tanh map for pause regions.
	if (logLrtTimeAvgKsum < threshPrior0) {
		widthPrior = widthPrior1;
	}
	// Compute indicator function: sigmoid map.
	indicator0 =
		0.5f *
		(tanhf(widthPrior * (logLrtTimeAvgKsum - threshPrior0)) + 1.f);

	// Spectral flatness feature.
	tmpFloat1 = self->featureData[0];
	widthPrior = widthPrior0;
	// Use larger width in tanh map for pause regions.
	if (sgnMap == 1 && (tmpFloat1 > threshPrior1)) {
		widthPrior = widthPrior1;
	}
	if (sgnMap == -1 && (tmpFloat1 < threshPrior1)) {
		widthPrior = widthPrior1;
	}
	// Compute indicator function: sigmoid map.
	indicator1 =
		0.5f *
		(tanhf((float)sgnMap * widthPrior * (threshPrior1 - tmpFloat1)) +
			1.f);

	// For template spectrum-difference.
	tmpFloat1 = self->featureData[4];
	widthPrior = widthPrior0;
	// Use larger width in tanh map for pause regions.
	if (tmpFloat1 < threshPrior2) {
		widthPrior = widthPrior2;
	}
	// Compute indicator function: sigmoid map.
	indicator2 =
		0.5f * (tanhf(widthPrior * (tmpFloat1 - threshPrior2)) + 1.f);

	// Combine the indicator function with the feature weights.
	indPrior = weightIndPrior0 * indicator0 + weightIndPrior1 * indicator1 +
		weightIndPrior2 * indicator2;
	// Done with computing indicator function.

	// Compute the prior probability.
	self->priorSpeechProb += PRIOR_UPDATE * (indPrior - self->priorSpeechProb);
	// Make sure probabilities are within range: keep floor to 0.01.
	if (self->priorSpeechProb > 1.f) {
		self->priorSpeechProb = 1.f;
	}
	if (self->priorSpeechProb < 0.01f) {
		self->priorSpeechProb = 0.01f;
	}

	// Final speech probability: combine prior model with LR factor:.
	gainPrior = (1.f - self->priorSpeechProb) / (self->priorSpeechProb + 0.0001f);
	for (i = 0; i < self->magnLen; i++) {
		invLrt = expf(-self->logLrtTimeAvg[i]);
		invLrt = gainPrior * invLrt;
		probSpeechFinal[i] = 1.f / (1.f + invLrt);
	}
}

// Update the noise features.
// Inputs:
//   * |magn| is the signal magnitude spectrum estimate.
//   * |updateParsFlag| is an update flag for parameters.
static void FeatureUpdate(NoiseSuppressionC *self,
	const float *magn,
	int updateParsFlag) {
	// Compute spectral flatness on input spectrum.
	ComputeSpectralFlatness(self, magn);
	// Compute difference of input spectrum with learned/estimated noise spectrum.
	ComputeSpectralDifference(self, magn);
	// Compute histograms for parameter decisions (thresholds and weights for
	// features).
	// Parameters are extracted once every window time.
	// (=self->modelUpdatePars[1])
	if (updateParsFlag >= 1) {
		// Counter update.
		self->modelUpdatePars[3]--;
		// Update histogram.
		if (self->modelUpdatePars[3] > 0) {
			FeatureParameterExtraction(self, 0);
		}
		// Compute model parameters.
		if (self->modelUpdatePars[3] == 0) {
			FeatureParameterExtraction(self, 1);
			self->modelUpdatePars[3] = self->modelUpdatePars[1];
			// If wish to update only once, set flag to zero.
			if (updateParsFlag == 1) {
				self->modelUpdatePars[0] = 0;
			}
			else {
				// Update every window:
				// Get normalization for spectral difference for next window estimate.
				self->featureData[6] =
					self->featureData[6] / ((float)self->modelUpdatePars[1]);
				self->featureData[5] =
					0.5f * (self->featureData[6] + self->featureData[5]);
				self->featureData[6] = 0.f;
			}
		}
	}
}


// Update the noise estimate.
// Inputs:
//   * |magn| is the signal magnitude spectrum estimate.
//   * |snrLocPrior| is the prior SNR.
//   * |snrLocPost| is the post SNR.
// Output:
//   * |noise| is the updated noise magnitude spectrum estimate.
static void UpdateNoiseEstimate(NoiseSuppressionC *self,
	const float *magn,
	float *noise) {
	size_t i;
	float probSpeech, probNonSpeech;
	// Time-avg parameter for noise update.
	float gammaNoiseTmp = NOISE_UPDATE;
	float gammaNoiseOld;
	float noiseUpdateTmp;

	for (i = 0; i < self->magnLen; i++) {
		probSpeech = self->speechProb[i];
		probNonSpeech = 1.f - probSpeech;
		// Temporary noise update:
		// Use it for speech frames if update value is less than previous.
		noiseUpdateTmp = gammaNoiseTmp * self->noisePrev[i] +
			(1.f - gammaNoiseTmp) * (probNonSpeech * magn[i] +
				probSpeech * self->noisePrev[i]);
		// Time-constant based on speech/noise state.
		gammaNoiseOld = gammaNoiseTmp;
		gammaNoiseTmp = NOISE_UPDATE;
		// Increase gamma (i.e., less noise update) for frame likely to be speech.
		if (probSpeech > PROB_RANGE) {
			gammaNoiseTmp = SPEECH_UPDATE;
		}
		// Conservative noise update.
		if (probSpeech < PROB_RANGE) {
			self->magnAvgPause[i] += GAMMA_PAUSE * (magn[i] - self->magnAvgPause[i]);
		}
		// Noise update.
		if (gammaNoiseTmp == gammaNoiseOld) {
			noise[i] = noiseUpdateTmp;
		}
		else {
			noise[i] = gammaNoiseTmp * self->noisePrev[i] +
				(1.f - gammaNoiseTmp) * (probNonSpeech * magn[i] +
					probSpeech * self->noisePrev[i]);
			// Allow for noise update downwards:
			// If noise update decreases the noise, it is safe, so allow it to
			// happen.
			if (noiseUpdateTmp < noise[i]) {
				noise[i] = noiseUpdateTmp;
			}
		}
	}  // End of freq loop.
}

// Updates |buffer| with a new |frame|.
// Inputs:
//   * |frame| is a new speech frame or NULL for setting to zero.
//   * |frame_length| is the length of the new frame.
//   * |buffer_length| is the length of the buffer.
// Output:
//   * |buffer| is the updated buffer.
static void UpdateBuffer(const int16_t *frame,
	size_t frame_length,
	size_t buffer_length,
	float *buffer) {
	assert(buffer_length < 2 * frame_length);

	memcpy(buffer,
		buffer + frame_length,
		sizeof(*buffer) * (buffer_length - frame_length));
	if (frame) {
		for (int i = 0; i < frame_length; ++i) {
			buffer[buffer_length - frame_length + i] = frame[i];
		}
	}
	else {
		memset(buffer + buffer_length - frame_length,
			0,
			sizeof(*buffer) * frame_length);
	}
}

// Transforms the signal from time to frequency domain.
// Inputs:
//   * |time_data| is the signal in the time domain.
//   * |time_data_length| is the length of the analysis buffer.
//   * |magnitude_length| is the length of the spectrum magnitude, which equals
//     the length of both |real| and |imag| (time_data_length / 2 + 1).
// Outputs:
//   * |time_data| is the signal in the frequency domain.
//   * |real| is the real part of the frequency domain.
//   * |imag| is the imaginary part of the frequency domain.
//   * |magn| is the calculated signal magnitude in the frequency domain.
static void FFT(NoiseSuppressionC *self,
	float *time_data,
	size_t time_data_length,
	size_t magnitude_length,
	float *real,
	float *imag,
	float *magn) {
	size_t i;

	assert(magnitude_length == time_data_length / 2 + 1);

	WebRtc_rdft(time_data_length, 1, time_data, self->ip, self->wfft);

	imag[0] = 0;
	real[0] = time_data[0];
	magn[0] = fabsf(real[0]) + 1.f;
	imag[magnitude_length - 1] = 0;
	real[magnitude_length - 1] = time_data[1];
	magn[magnitude_length - 1] = fabsf(real[magnitude_length - 1]) + 1.f;
	for (i = 1; i < magnitude_length - 1; ++i) {
		real[i] = time_data[2 * i];
		imag[i] = time_data[2 * i + 1];
		// Magnitude spectrum.
		magn[i] = sqrtf(real[i] * real[i] + imag[i] * imag[i]) + 1.f;
	}
}

// Transforms the signal from frequency to time domain.
// Inputs:
//   * |real| is the real part of the frequency domain.
//   * |imag| is the imaginary part of the frequency domain.
//   * |magnitude_length| is the length of the spectrum magnitude, which equals
//     the length of both |real| and |imag|.
//   * |time_data_length| is the length of the analysis buffer
//     (2 * (magnitude_length - 1)).
// Output:
//   * |time_data| is the signal in the time domain.
static void IFFT(NoiseSuppressionC *self,
	const float *real,
	const float *imag,
	size_t magnitude_length,
	size_t time_data_length,
	float *time_data) {
	size_t i;

	assert(time_data_length == 2 * (magnitude_length - 1));

	time_data[0] = real[0];
	time_data[1] = real[magnitude_length - 1];
	for (i = 1; i < magnitude_length - 1; ++i) {
		time_data[2 * i] = real[i];
		time_data[2 * i + 1] = imag[i];
	}
	WebRtc_rdft(time_data_length, -1, time_data, self->ip, self->wfft);

	for (i = 0; i < time_data_length; ++i) {
		time_data[i] *= 2.f / time_data_length;  // FFT scaling.
	}
}

// Calculates the energy of a buffer.
// Inputs:
//   * |buffer| is the buffer over which the energy is calculated.
//   * |length| is the length of the buffer.
// Returns the calculated energy.
static float Energy(const float *buffer, size_t length) {
	size_t i;
	float energy = 0.f;

	for (i = 0; i < length; ++i) {
		energy += buffer[i] * buffer[i];
	}

	return energy;
}

// Windows a buffer.
// Inputs:
//   * |window| is the window by which to multiply.
//   * |data| is the data without windowing.
//   * |length| is the length of the window and data.
// Output:
//   * |data_windowed| is the windowed data.
static void Windowing(const float *window,
	const float *data,
	size_t length,
	float *data_windowed) {
	size_t i;

	for (i = 0; i < length; ++i) {
		data_windowed[i] = window[i] * data[i];
	}
}

// Estimate prior SNR decision-directed and compute DD based Wiener Filter.
//SNR
// Input:
//   * |magn| is the signal magnitude spectrum estimate.
// Output:
//   * |theFilter| is the frequency response of the computed Wiener filter.
static void ComputeDdBasedWienerFilter(const NoiseSuppressionC *self,
	const float *magn,
	float *theFilter) {
	size_t i;
	float snrPrior, previousEstimateStsa, currentEstimateStsa;

	for (i = 0; i < self->magnLen; i++) {
		// Previous estimate: based on previous frame with gain filter.
		previousEstimateStsa = self->magnPrevProcess[i] /
			(self->noisePrev[i] + 0.0001f) * self->smooth[i];
		// Post and prior SNR.
		currentEstimateStsa = 0.f;
		if (magn[i] > self->noise[i]) {
			currentEstimateStsa = magn[i] / (self->noise[i] + 0.0001f) - 1.f;
		}
		// DD estimate is sum of two terms: current estimate and previous estimate.
		// Directed decision update of |snrPrior|.
		snrPrior = DD_PR_SNR * previousEstimateStsa +
			(1.f - DD_PR_SNR) * currentEstimateStsa;
		// Gain filter.
		theFilter[i] = snrPrior / (self->overdrive + snrPrior);
	}  // End of loop over frequencies.
}


// Changes the aggressiveness of the noise suppression method.
//
// |mode| = 0 is mild (6dB), |mode| = 1 is medium (10dB) and |mode| = 2 is
// aggressive (15dB).
// Returns 0 on success and -1 otherwise.
int WebRtcNs_set_policy_core(NoiseSuppressionC *self, int mode) {
	// Allow for modes: 0, 1, 2, 3.
	if (mode == 0) {
		self->overdrive = 1.f;
		self->denoiseBound = 0.5f;
		self->gainmap = 0;
	}
	else if (mode == 1) {
		// self->overdrive = 1.25f;
		self->overdrive = 1.f;
		self->denoiseBound = 0.25f;
		self->gainmap = 1;
	}
	else if (mode == 2) {
		// self->overdrive = 1.25f;
		self->overdrive = 1.1f;
		self->denoiseBound = 0.125f;
		self->gainmap = 1;
	}
	else if (mode == 3) {
		// self->overdrive = 1.3f;
		self->overdrive = 1.25f;
		self->denoiseBound = 0.09f;
		self->gainmap = 1;
	}
	else {
		return -1;
	}
	self->aggrMode = mode;
	return 0;
}

//
void WebRtcNs_AnalyzeCore(NoiseSuppressionC *self, const int16_t *speechFrame) {
	size_t i;
	const size_t kStartBand = 5;  // Skip first frequency bins during estimation.
	int updateParsFlag;
	float energy;
	float signalEnergy = 0.f;
	float sumMagn = 0.f;
	float tmpFloat1, tmpFloat2, tmpFloat3;
	float winData[ANAL_BLOCKL_MAX];
	float magn[HALF_ANAL_BLOCKL], noise[HALF_ANAL_BLOCKL];
	float snrLocPost[HALF_ANAL_BLOCKL], snrLocPrior[HALF_ANAL_BLOCKL];
	float real[ANAL_BLOCKL_MAX], imag[HALF_ANAL_BLOCKL];
	// Variables during startup.
	float sum_log_i = 0.0;
	float sum_log_i_square = 0.0;
	float sum_log_magn = 0.0;
	float sum_log_i_log_magn = 0.0;
	float parametric_exp = 0.0;
	float parametric_num = 0.0;

	// Check that initiation has been done.
	assert(1 == self->initFlag);
	updateParsFlag = self->modelUpdatePars[0];

	// Update analysis buffer for L band.
	UpdateBuffer(speechFrame, self->blockLen, self->anaLen, self->analyzeBuf);

	Windowing(self->window, self->analyzeBuf, self->anaLen, winData);
	energy = Energy(winData, self->anaLen);
	if (energy == 0.0) {
		// We want to avoid updating statistics in this case:
		// Updating feature statistics when we have zeros only will cause
		// thresholds to move towards zero signal situations. This in turn has the
		// effect that once the signal is "turned on" (non-zero values) everything
		// will be treated as speech and there is no noise suppression effect.
		// Depending on the duration of the inactive signal it takes a
		// considerable amount of time for the system to learn what is noise and
		// what is speech.
		return;
	}

	self->blockInd++;  // Update the block index only when we process a block.

	FFT(self, winData, self->anaLen, self->magnLen, real, imag, magn);

	for (i = 0; i < self->magnLen; i++) {
		signalEnergy += real[i] * real[i] + imag[i] * imag[i];
		sumMagn += magn[i];
		if (self->blockInd < END_STARTUP_SHORT) {
			if (i >= kStartBand) {
				tmpFloat2 = logf((float)i);
				sum_log_i += tmpFloat2;
				sum_log_i_square += tmpFloat2 * tmpFloat2;
				tmpFloat1 = logf(magn[i]);
				sum_log_magn += tmpFloat1;
				sum_log_i_log_magn += tmpFloat2 * tmpFloat1;
			}
		}
	}
	signalEnergy /= self->magnLen;
	self->signalEnergy = signalEnergy;
	self->sumMagn = sumMagn;

	// Quantile noise estimate.
	NoiseEstimation(self, magn, noise);
	// Compute simplified noise model during startup.
	if (self->blockInd < END_STARTUP_SHORT) {
		// Estimate White noise.
		self->whiteNoiseLevel += sumMagn / self->magnLen * self->overdrive;
		// Estimate Pink noise parameters.
		tmpFloat1 = sum_log_i_square * (self->magnLen - kStartBand);
		tmpFloat1 -= (sum_log_i * sum_log_i);
		tmpFloat2 =
			(sum_log_i_square * sum_log_magn - sum_log_i * sum_log_i_log_magn);
		tmpFloat3 = tmpFloat2 / tmpFloat1;
		// Constrain the estimated spectrum to be positive.
		if (tmpFloat3 < 0.f) {
			tmpFloat3 = 0.f;
		}
		self->pinkNoiseNumerator += tmpFloat3;
		tmpFloat2 = (sum_log_i * sum_log_magn);
		tmpFloat2 -= (self->magnLen - kStartBand) * sum_log_i_log_magn;
		tmpFloat3 = tmpFloat2 / tmpFloat1;
		// Constrain the pink noise power to be in the interval [0, 1].
		if (tmpFloat3 < 0.f) {
			tmpFloat3 = 0.f;
		}
		if (tmpFloat3 > 1.f) {
			tmpFloat3 = 1.f;
		}
		self->pinkNoiseExp += tmpFloat3;

		// Calculate frequency independent parts of parametric noise estimate.
		if (self->pinkNoiseExp > 0.f) {
			// Use pink noise estimate.
			parametric_num =
				expf(self->pinkNoiseNumerator / (float)(self->blockInd + 1));
			parametric_num *= (float)(self->blockInd + 1);
			parametric_exp = self->pinkNoiseExp / (float)(self->blockInd + 1);
		}
		for (i = 0; i < self->magnLen; i++) {
			// Estimate the background noise using the white and pink noise
			// parameters.
			if (self->pinkNoiseExp == 0.f) {
				// Use white noise estimate.
				self->parametricNoise[i] = self->whiteNoiseLevel;
			}
			else {
				// Use pink noise estimate.
				float use_band = (float)(i < kStartBand ? kStartBand : i);
				self->parametricNoise[i] =
					parametric_num / powf(use_band, parametric_exp);
			}
			// Weight quantile noise with modeled noise.
			noise[i] *= (self->blockInd);
			tmpFloat2 =
				self->parametricNoise[i] * (END_STARTUP_SHORT - self->blockInd);
			noise[i] += (tmpFloat2 / (float)(self->blockInd + 1));
			noise[i] /= END_STARTUP_SHORT;
		}
	}
	// Compute average signal during END_STARTUP_LONG time:
	// used to normalize spectral difference measure.
	if (self->blockInd < END_STARTUP_LONG) {
		self->featureData[5] *= self->blockInd;
		self->featureData[5] += signalEnergy;
		self->featureData[5] /= (self->blockInd + 1);
	}

	// Post and prior SNR needed for SpeechNoiseProb.
	ComputeSnr(self, magn, noise, snrLocPrior, snrLocPost);

	FeatureUpdate(self, magn, updateParsFlag);
	SpeechNoiseProb(self, self->speechProb, snrLocPrior, snrLocPost);
	UpdateNoiseEstimate(self, magn, noise);

	// Keep track of noise spectrum for next frame.
	memcpy(self->noise, noise, sizeof(*noise) * self->magnLen);
	memcpy(self->magnPrevAnalyze, magn, sizeof(*magn) * self->magnLen);
}

//
void WebRtcNs_ProcessCore(NoiseSuppressionC *self,
	const int16_t *const *speechFrame,
	size_t num_bands,
	int16_t *const *outFrame) {
	// Main routine for noise reduction.
	int flagHB = 0;
	size_t i, j;

	float energy1, energy2, gain, factor, factor1, factor2;
	float fout[BLOCKL_MAX];
	float winData[ANAL_BLOCKL_MAX];
	float magn[HALF_ANAL_BLOCKL];
	float theFilter[HALF_ANAL_BLOCKL], theFilterTmp[HALF_ANAL_BLOCKL];
	float real[ANAL_BLOCKL_MAX], imag[HALF_ANAL_BLOCKL];

	// SWB variables.
	int deltaBweHB = 1;
	int deltaGainHB = 1;
	float decayBweHB = 1.0;
	float gainMapParHB = 1.0;
	float avgProbSpeechHB, avgProbSpeechHBTmp, avgFilterGainHB, gainModHB;
	float sumMagnAnalyze, sumMagnProcess;

	// Check that initiation has been done.
	assert(1 == self->initFlag);
	assert(num_bands - 1 <= NUM_HIGH_BANDS_MAX);

	const int16_t *const *speechFrameHB = NULL;
	int16_t *const *outFrameHB = NULL;
	size_t num_high_bands = 0;
	if (num_bands > 1) {
		speechFrameHB = &speechFrame[1];
		outFrameHB = &outFrame[1];
		num_high_bands = num_bands - 1;
		flagHB = 1;
		// Range for averaging low band quantities for H band gain.
		deltaBweHB = (int)self->magnLen / 4;
		deltaGainHB = deltaBweHB;
	}

	// Update analysis buffer for L band.
	UpdateBuffer(speechFrame[0], self->blockLen, self->anaLen, self->dataBuf);

	if (flagHB == 1) {
		// Update analysis buffer for H bands.
		for (i = 0; i < num_high_bands; ++i) {
			UpdateBuffer(speechFrameHB[i],
				self->blockLen,
				self->anaLen,
				self->dataBufHB[i]);
		}
	}

	Windowing(self->window, self->dataBuf, self->anaLen, winData);
	energy1 = Energy(winData, self->anaLen);
	if (energy1 == 0.0) {
		// Synthesize the special case of zero input.
		// Read out fully processed segment.
		for (i = self->windShift; i < self->blockLen + self->windShift; i++) {
			fout[i - self->windShift] = self->syntBuf[i];
		}
		// Update synthesis buffer.
		UpdateBuffer(NULL, self->blockLen, self->anaLen, self->syntBuf);

		for (i = 0; i < self->blockLen; ++i)
			outFrame[0][i] =
			SPL_SAT(32767, fout[i], (-32768));

		// For time-domain gain of HB.
		if (flagHB == 1) {
			for (i = 0; i < num_high_bands; ++i) {
				for (j = 0; j < self->blockLen; ++j) {
					outFrameHB[i][j] = SPL_SAT(32767,
						self->dataBufHB[i][j],
						(-32768));
				}
			}
		}

		return;
	}

	FFT(self, winData, self->anaLen, self->magnLen, real, imag, magn);

	if (self->blockInd < END_STARTUP_SHORT) {
		for (i = 0; i < self->magnLen; i++) {
			self->initMagnEst[i] += magn[i];
		}
	}

	ComputeDdBasedWienerFilter(self, magn, theFilter);

	for (i = 0; i < self->magnLen; i++) {
		// Flooring bottom.
		if (theFilter[i] < self->denoiseBound) {
			theFilter[i] = self->denoiseBound;
		}
		// Flooring top.
		if (theFilter[i] > 1.f) {
			theFilter[i] = 1.f;
		}
		if (self->blockInd < END_STARTUP_SHORT) {
			theFilterTmp[i] =
				(self->initMagnEst[i] - self->overdrive * self->parametricNoise[i]);
			theFilterTmp[i] /= (self->initMagnEst[i] + 0.0001f);
			// Flooring bottom.
			if (theFilterTmp[i] < self->denoiseBound) {
				theFilterTmp[i] = self->denoiseBound;
			}
			// Flooring top.
			if (theFilterTmp[i] > 1.f) {
				theFilterTmp[i] = 1.f;
			}
			// Weight the two suppression filters.
			theFilter[i] *= (self->blockInd);
			theFilterTmp[i] *= (END_STARTUP_SHORT - self->blockInd);
			theFilter[i] += theFilterTmp[i];
			theFilter[i] /= (END_STARTUP_SHORT);
		}

		self->smooth[i] = theFilter[i];
		real[i] *= self->smooth[i];
		imag[i] *= self->smooth[i];
	}
	// Keep track of |magn| spectrum for next frame.
	memcpy(self->magnPrevProcess, magn, sizeof(*magn) * self->magnLen);
	memcpy(self->noisePrev, self->noise, sizeof(self->noise[0]) * self->magnLen);
	// Back to time domain.
	IFFT(self, real, imag, self->magnLen, self->anaLen, winData);

	// Scale factor: only do it after END_STARTUP_LONG time.
	factor = 1.f;
	if (self->gainmap == 1 && self->blockInd > END_STARTUP_LONG) {
		factor1 = 1.f;
		factor2 = 1.f;
		energy2 = Energy(winData, self->anaLen);
		gain = sqrtf(energy2 / (energy1 + 1.f));

		// Scaling for new version.
		if (gain > B_LIM) {
			factor1 = 1.f + 1.3f * (gain - B_LIM);
			if (gain * factor1 > 1.f) {
				factor1 = 1.f / gain;
			}
		}
		if (gain < B_LIM) {
			// Don't reduce scale too much for pause regions:
			// attenuation here should be controlled by flooring.
			if (gain <= self->denoiseBound) {
				gain = self->denoiseBound;
			}
			factor2 = 1.f - 0.3f * (B_LIM - gain);
		}
		// Combine both scales with speech/noise prob:
		// note prior (priorSpeechProb) is not frequency dependent.
		factor = self->priorSpeechProb * factor1 +
			(1.f - self->priorSpeechProb) * factor2;
	}  // Out of self->gainmap == 1.

	Windowing(self->window, winData, self->anaLen, winData);

	// Synthesis.
	for (i = 0; i < self->anaLen; i++) {
		self->syntBuf[i] += factor * winData[i];
	}
	// Read out fully processed segment.
	for (i = self->windShift; i < self->blockLen + self->windShift; i++) {
		fout[i - self->windShift] = self->syntBuf[i];
	}
	// Update synthesis buffer.
	UpdateBuffer(NULL, self->blockLen, self->anaLen, self->syntBuf);

	for (i = 0; i < self->blockLen; ++i)
		outFrame[0][i] =
		SPL_SAT(32767, fout[i], (-32768));

	// For time-domain gain of HB.
	if (flagHB == 1) {
		// Average speech prob from low band.
		// Average over second half (i.e., 4->8kHz) of frequencies spectrum.
		avgProbSpeechHB = 0.0;
		for (i = self->magnLen - deltaBweHB - 1; i < self->magnLen - 1; i++) {
			avgProbSpeechHB += self->speechProb[i];
		}
		avgProbSpeechHB = avgProbSpeechHB / ((float)deltaBweHB);
		// If the speech was suppressed by a component between Analyze and
		// Process, for example the AEC, then it should not be considered speech
		// for high band suppression purposes.
		sumMagnAnalyze = 0;
		sumMagnProcess = 0;
		for (i = 0; i < self->magnLen; ++i) {
			sumMagnAnalyze += self->magnPrevAnalyze[i];
			sumMagnProcess += self->magnPrevProcess[i];
		}
		avgProbSpeechHB *= sumMagnProcess / sumMagnAnalyze;
		// Average filter gain from low band.
		// Average over second half (i.e., 4->8kHz) of frequencies spectrum.
		avgFilterGainHB = 0.0;
		for (i = self->magnLen - deltaGainHB - 1; i < self->magnLen - 1; i++) {
			avgFilterGainHB += self->smooth[i];
		}
		avgFilterGainHB = avgFilterGainHB / ((float)(deltaGainHB));
		avgProbSpeechHBTmp = 2.f * avgProbSpeechHB - 1.f;
		// Gain based on speech probability.
		gainModHB = 0.5f * (1.f + tanhf(gainMapParHB * avgProbSpeechHBTmp));
		// Combine gain with low band gain.
		float gainTimeDomainHB = 0.5f * gainModHB + 0.5f * avgFilterGainHB;
		if (avgProbSpeechHB >= 0.5f) {
			gainTimeDomainHB = 0.25f * gainModHB + 0.75f * avgFilterGainHB;
		}
		gainTimeDomainHB = gainTimeDomainHB * decayBweHB;
		// Make sure gain is within flooring range.
		// Flooring bottom.
		if (gainTimeDomainHB < self->denoiseBound) {
			gainTimeDomainHB = self->denoiseBound;
		}
		// Flooring top.
		if (gainTimeDomainHB > 1.f) {
			gainTimeDomainHB = 1.f;
		}
		// Apply gain.
		for (i = 0; i < num_high_bands; ++i) {
			for (j = 0; j < self->blockLen; j++) {
				outFrameHB[i][j] =
					SPL_SAT(32767,
						gainTimeDomainHB * self->dataBufHB[i][j],
						(-32768));
			}
		}
	}  // End of H band gain computation.
}

NsHandle *WebRtcNs_Create() {
	NoiseSuppressionC *self = (NoiseSuppressionC *)malloc(sizeof(NoiseSuppressionC));
	if (self != NULL) {
		self->initFlag = 0;
	}
	return (NsHandle *)self;
}



void WebRtcNs_Free(NsHandle *NS_inst) {
	free(NS_inst);
}

int WebRtcNs_Init(NsHandle* NS_inst, uint32_t fs) {
	return WebRtcNs_InitCore((NoiseSuppressionC*)NS_inst, fs);
}

int WebRtcNs_set_policy(NsHandle *NS_inst, int mode) {
	return WebRtcNs_set_policy_core((NoiseSuppressionC *)NS_inst, mode);
}

void WebRtcNs_Analyze(NsHandle *NS_inst, const int16_t *spframe) {
	WebRtcNs_AnalyzeCore((NoiseSuppressionC *)NS_inst, spframe);
}

void WebRtcNs_Process(NsHandle* NS_inst,
	const int16_t *const *spframe,
	size_t num_bands,
	int16_t *const *outframe) {
	WebRtcNs_ProcessCore((NoiseSuppressionC*)NS_inst, spframe, num_bands,
		outframe);
}

float WebRtcNs_prior_speech_probability(NsHandle* handle) {
	NoiseSuppressionC* self = (NoiseSuppressionC*)handle;
	if (handle == NULL) {
		return -1;
	}
	if (self->initFlag == 0) {
		return -1;
	}
	return self->priorSpeechProb;
}

const float* WebRtcNs_noise_estimate(const NsHandle* handle) {
	const NoiseSuppressionC* self = (const NoiseSuppressionC*)handle;
	if (handle == NULL || self->initFlag == 0) {
		return NULL;
	}
	return self->noise;
}

size_t WebRtcNs_num_freq() {
	return HALF_ANAL_BLOCKL;
}